From 1f116553b6f685b0ab0303174e1d6ff73c85459f Mon Sep 17 00:00:00 2001
From: quintus-lab<noreply@github.com>
Date: Fri, 5 Mar 2021 21:21:53 +0800
Subject: [PATCH] new_rockchip_support_k510

 This introduces rockchip ddrloader firmware, which allows users to control the memory frequency
 runtime. This introduces rockchip ddrloader firmware, which allows users to control the memory frequency runtime. 
 Signed-off-by: AmadeusGhost <amadeus@immortalwrt.org> 
 Signed-off-by: Tianling Shen <cnsztl@immortalwrt.org> 

 R4S support:
 Signed-off-by: Tianling Shen <cnsztl@gmail.com> Co-authored-by: Jensen Huang
 <jensenhuang@friendlyarm.com> Signed-off-by: Jensen Huang
 <jensenhuang@friendlyarm.com> Co-authored-by: Marty Jones
 <mj8263788@gmail.com> Signed-off-by: Marty Jones <mj8263788@gmail.com> 
----
 new file:   package/boot/arm-trusted-firmware-rk3328/Makefile
 new file:   package/boot/arm-trusted-firmware-rk3328/src/trust.ini 
 modified:   package/boot/uboot-rockchip/Makefile 
 new file:   package/boot/uboot-rockchip/patches/200-rockchip-rk3399-split-nanopi-r4-rk3399-out-of-evb_rk.patch
 new file:   package/boot/uboot-rockchip/patches/201-ram-rk3399-Add-support-for-multiple-DDR-types.patch
 new file:   package/boot/uboot-rockchip/patches/202-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
 new file:   target/linux/generic/hack-5.10/310-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch
 new file:   target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
 modified:   target/linux/rockchip/Makefile 
 modified:   target/linux/rockchip/armv8/base-files/etc/board.d/01_leds 
 modified:   target/linux/rockchip/armv8/base-files/etc/board.d/02_network 
 modified:   target/linux/rockchip/armv8/base-files/etc/hotplug.d/net/40-net-smp-affinity
 modified:   target/linux/rockchip/armv8/config-5.10 modified:   target/linux/rockchip/armv8/config-5.4 
 new file:   target/linux/rockchip/files/arch/arm64/boot/dts/rockchip/rk3328-dram-nanopi2-timing.dtsi
 new file:   target/linux/rockchip/files/drivers/devfreq/rk3328_dmc.c 
 new file:   target/linux/rockchip/files/include/dt-bindings/clock/rockchip-ddr.h
 new file:   target/linux/rockchip/files/include/dt-bindings/memory/rk3328-dram.h
 modified:   target/linux/rockchip/image/Makefile
 modified:   target/linux/rockchip/image/armv8.mk 
 new file:   target/linux/rockchip/image/nanopi-r4s.bootscript 
 new file:   target/linux/rockchip/patches-5.10/005-rockchip-rk3328-add-compatible-to-NanoPi-R2S-etherne.patch
 new file:   target/linux/rockchip/patches-5.10/105-mmc-core-set-initial-signal-voltage-on-power-off.patch
 new file:   target/linux/rockchip/patches-5.10/200-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
 new file:   target/linux/rockchip/patches-5.10/201-rockchip-rk3328-add-i2c0-controller-for-nanopi-r2s.patch
 new file:   target/linux/rockchip/patches-5.10/801-char-add-support-for-rockchip-hardware-random-number.patch
 new file:   target/linux/rockchip/patches-5.10/802-arm64-dts-rockchip-add-hardware-random-number-genera.patch
 new file:   target/linux/rockchip/patches-5.10/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
 new file:   target/linux/rockchip/patches-5.10/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
 new file:   target/linux/rockchip/patches-5.10/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
 new file:   target/linux/rockchip/patches-5.10/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
 new file:   target/linux/rockchip/patches-5.10/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
 new file:   target/linux/rockchip/patches-5.10/911-kernel-dma-adjust-default-coherent_pool-to-2MiB.patch
 new file:   target/linux/rockchip/patches-5.10/991-arm64-dts-rockchip-add-more-cpu-operating-points-for.patch
 new file:   target/linux/rockchip/patches-5.10/992-rockchip-rk3399-overclock-to-2.2-1.8-GHz-for-NanoPi4.patch
 new file:   target/linux/rockchip/patches-5.4/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
 new file:   target/linux/rockchip/patches-5.4/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
 new file:   target/linux/rockchip/patches-5.4/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
 new file:   target/linux/rockchip/patches-5.4/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
 new file:   target/linux/rockchip/patches-5.4/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
---
 .../boot/arm-trusted-firmware-rk3328/Makefile |  57 ++
 .../arm-trusted-firmware-rk3328/src/trust.ini |  15 +
 package/boot/uboot-rockchip/Makefile          |  25 +-
 ...split-nanopi-r4-rk3399-out-of-evb_rk.patch | 509 +++++++++++
 ...9-Add-support-for-multiple-DDR-types.patch | 256 ++++++
 ...Add-support-for-FriendlyARM-NanoPi-R.patch | 313 +++++++
 ...el-name-in-proc-cpuinfo-for-64bit-ta.patch |  38 +
 ...k-events-support-multiple-registrant.patch | 291 ++++++
 target/linux/rockchip/Makefile                |   2 +-
 .../armv8/base-files/etc/board.d/01_leds      |   3 +-
 .../armv8/base-files/etc/board.d/02_network   |   7 +-
 .../etc/hotplug.d/net/40-net-smp-affinity     |   4 +
 target/linux/rockchip/armv8/config-5.10       |   5 +
 target/linux/rockchip/armv8/config-5.4        |   1 +
 .../rockchip/rk3328-dram-nanopi2-timing.dtsi  | 311 +++++++
 .../files/drivers/devfreq/rk3328_dmc.c        | 852 ++++++++++++++++++
 .../include/dt-bindings/clock/rockchip-ddr.h  |  63 ++
 .../include/dt-bindings/memory/rk3328-dram.h  | 159 ++++
 target/linux/rockchip/image/Makefile          |  14 +
 target/linux/rockchip/image/armv8.mk          |  12 +-
 .../rockchip/image/nanopi-r4s.bootscript      |   8 +
 ...add-compatible-to-NanoPi-R2S-etherne.patch |  25 +
 ...-initial-signal-voltage-on-power-off.patch |  35 +
 ...Add-support-for-FriendlyARM-NanoPi-R.patch | 218 +++++
 ...8-add-i2c0-controller-for-nanopi-r2s.patch |  22 +
 ...-for-rockchip-hardware-random-number.patch |  45 +
 ...ip-add-hardware-random-number-genera.patch |  50 +
 ...ip-add-devfreq-driver-for-rk3328-dmc.patch |  44 +
 ...setting-ddr-clock-via-SIP-Version-2-.patch | 218 +++++
 ...eq-rockchip-dfi-add-more-soc-support.patch | 662 ++++++++++++++
 ...m64-dts-rockchip-rk3328-add-dfi-node.patch |  27 +
 ...anopi-r2s-add-rk3328-dmc-relate-node.patch | 126 +++
 ...adjust-default-coherent_pool-to-2MiB.patch |  28 +
 ...ip-add-more-cpu-operating-points-for.patch |  44 +
 ...overclock-to-2.2-1.8-GHz-for-NanoPi4.patch | 186 ++++
 ...ip-add-devfreq-driver-for-rk3328-dmc.patch |  48 +
 ...setting-ddr-clock-via-SIP-Version-2-.patch | 218 +++++
 ...eq-rockchip-dfi-add-more-soc-support.patch | 665 ++++++++++++++
 ...m64-dts-rockchip-rk3328-add-dfi-node.patch |  27 +
 ...anopi-r2s-add-rk3328-dmc-relate-node.patch | 126 +++
 40 files changed, 5752 insertions(+), 7 deletions(-)
 create mode 100644 package/boot/arm-trusted-firmware-rk3328/Makefile
 create mode 100644 package/boot/arm-trusted-firmware-rk3328/src/trust.ini
 create mode 100644 package/boot/uboot-rockchip/patches/200-rockchip-rk3399-split-nanopi-r4-rk3399-out-of-evb_rk.patch
 create mode 100644 package/boot/uboot-rockchip/patches/201-ram-rk3399-Add-support-for-multiple-DDR-types.patch
 create mode 100644 package/boot/uboot-rockchip/patches/202-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
 create mode 100644 target/linux/generic/hack-5.10/310-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch
 create mode 100644 target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
 create mode 100644 target/linux/rockchip/files/arch/arm64/boot/dts/rockchip/rk3328-dram-nanopi2-timing.dtsi
 create mode 100644 target/linux/rockchip/files/drivers/devfreq/rk3328_dmc.c
 create mode 100644 target/linux/rockchip/files/include/dt-bindings/clock/rockchip-ddr.h
 create mode 100644 target/linux/rockchip/files/include/dt-bindings/memory/rk3328-dram.h
 create mode 100644 target/linux/rockchip/image/nanopi-r4s.bootscript
 create mode 100644 target/linux/rockchip/patches-5.10/005-rockchip-rk3328-add-compatible-to-NanoPi-R2S-etherne.patch
 create mode 100644 target/linux/rockchip/patches-5.10/105-mmc-core-set-initial-signal-voltage-on-power-off.patch
 create mode 100644 target/linux/rockchip/patches-5.10/200-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
 create mode 100644 target/linux/rockchip/patches-5.10/201-rockchip-rk3328-add-i2c0-controller-for-nanopi-r2s.patch
 create mode 100644 target/linux/rockchip/patches-5.10/801-char-add-support-for-rockchip-hardware-random-number.patch
 create mode 100644 target/linux/rockchip/patches-5.10/802-arm64-dts-rockchip-add-hardware-random-number-genera.patch
 create mode 100644 target/linux/rockchip/patches-5.10/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
 create mode 100644 target/linux/rockchip/patches-5.10/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
 create mode 100644 target/linux/rockchip/patches-5.10/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
 create mode 100644 target/linux/rockchip/patches-5.10/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
 create mode 100644 target/linux/rockchip/patches-5.10/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
 create mode 100644 target/linux/rockchip/patches-5.10/911-kernel-dma-adjust-default-coherent_pool-to-2MiB.patch
 create mode 100644 target/linux/rockchip/patches-5.10/991-arm64-dts-rockchip-add-more-cpu-operating-points-for.patch
 create mode 100644 target/linux/rockchip/patches-5.10/992-rockchip-rk3399-overclock-to-2.2-1.8-GHz-for-NanoPi4.patch
 create mode 100644 target/linux/rockchip/patches-5.4/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
 create mode 100644 target/linux/rockchip/patches-5.4/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
 create mode 100644 target/linux/rockchip/patches-5.4/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
 create mode 100644 target/linux/rockchip/patches-5.4/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
 create mode 100644 target/linux/rockchip/patches-5.4/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch

diff --git a/package/boot/arm-trusted-firmware-rk3328/Makefile b/package/boot/arm-trusted-firmware-rk3328/Makefile
new file mode 100644
index 0000000000..32fab196b5
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-rk3328/Makefile
@@ -0,0 +1,57 @@
+#
+# Copyright (C) 2020 Tobias Maedel <openwrt@tbspace.de>
+#
+# Copyright (C) 2021 ImmortalWrt
+# (https://immortalwrt.org)
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=arm-trusted-firmware-rk3328
+PKG_RELEASE:=1
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_URL=https://github.com/rockchip-linux/rkbin.git
+PKG_SOURCE_DATE:=2020-10-30
+PKG_SOURCE_VERSION:=0bb1c512492386a72a3a0b5a0e18e49c636577b9
+PKG_MIRROR_HASH:=6dffe95b83f37a280f98c105fce529f45e39ce333b24709a9645aac1352457ce
+
+PKG_MAINTAINER:=
+
+MAKE_PATH:=$(PKG_NAME)
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/arm-trusted-firmware-rk3328
+    SECTION:=boot
+    CATEGORY:=Boot Loaders
+    TITLE:=ARM Trusted Firmware for Rockchip
+    DEPENDS:=@TARGET_rockchip_armv8
+endef
+
+define Build/Configure
+	$(SED) 's,$$$$(PKG_BUILD_DIR),$(PKG_BUILD_DIR),g' $(PKG_BUILD_DIR)/trust.ini
+	$(call Build/Configure/Default)
+endef
+
+define Build/Compile
+	mkimage -n rk3328 -T rksd -d $(PKG_BUILD_DIR)/bin/rk33/rk3328_ddr_333MHz_v1.16.bin $(PKG_BUILD_DIR)/idbloader.bin
+	cat $(PKG_BUILD_DIR)/bin/rk33/rk322xh_miniloader_v2.50.bin >> $(PKG_BUILD_DIR)/idbloader.bin
+	$(PKG_BUILD_DIR)/tools/trust_merger --replace bl31.elf $(PKG_BUILD_DIR)/bin/rk33/rk322xh_bl31_v1.44.elf $(PKG_BUILD_DIR)/trust.ini
+endef
+
+define Build/InstallDev
+	$(INSTALL_DIR) -p $(STAGING_DIR_IMAGE)
+	$(CP) $(PKG_BUILD_DIR)/bin/rk33/rk322xh_bl31_v1.44.elf $(STAGING_DIR_IMAGE)/
+	$(CP) $(PKG_BUILD_DIR)/tools/loaderimage $(STAGING_DIR_IMAGE)/
+	$(CP) $(PKG_BUILD_DIR)/idbloader.bin $(STAGING_DIR_IMAGE)/
+	$(CP) $(PKG_BUILD_DIR)/trust.bin $(STAGING_DIR_IMAGE)/
+endef
+
+define Package/arm-trusted-firmware-rk3328/install
+endef
+
+$(eval $(call BuildPackage,arm-trusted-firmware-rk3328))
diff --git a/package/boot/arm-trusted-firmware-rk3328/src/trust.ini b/package/boot/arm-trusted-firmware-rk3328/src/trust.ini
new file mode 100644
index 0000000000..b95797427e
--- /dev/null
+++ b/package/boot/arm-trusted-firmware-rk3328/src/trust.ini
@@ -0,0 +1,15 @@
+[VERSION]
+MAJOR=1
+MINOR=0
+[BL30_OPTION]
+SEC=0
+[BL31_OPTION]
+SEC=1
+PATH=bl31.elf
+ADDR=0x10000
+[BL32_OPTION]
+SEC=0
+[BL33_OPTION]
+SEC=0
+[OUTPUT]
+PATH=$(PKG_BUILD_DIR)/trust.bin
diff --git a/package/boot/uboot-rockchip/Makefile b/package/boot/uboot-rockchip/Makefile
index 393e8c3a9f..a0e6d06383 100644
--- a/package/boot/uboot-rockchip/Makefile
+++ b/package/boot/uboot-rockchip/Makefile
@@ -29,15 +29,26 @@ define U-Boot/nanopi-r2s-rk3328
   NAME:=NanoPi R2S
   BUILD_DEVICES:= \
     friendlyarm_nanopi-r2s
-  DEPENDS:=+PACKAGE_u-boot-nanopi-r2s-rk3328:arm-trusted-firmware-rockchip
-  PKG_BUILD_DEPENDS:=arm-trusted-firmware-rockchip
-  ATF:=rk3328_bl31.elf
+  DEPENDS:=+PACKAGE_u-boot-nanopi-r2s-rk3328:arm-trusted-firmware-rk3328
+  PKG_BUILD_DEPENDS:=arm-trusted-firmware-rk3328
+  ATF:=rk322xh_bl31_v1.44.elf
+  USE_RKBIN:=1
   OF_PLATDATA:=$(1)
 endef
 
 
 # RK3399 boards
 
+define U-Boot/nanopi-r4s-rk3399
+  BUILD_SUBTARGET:=armv8
+  NAME:=NanoPi R4S
+  BUILD_DEVICES:= \
+    friendlyarm_nanopi-r4s
+  DEPENDS:=+PACKAGE_u-boot-nanopi-r4s-rk3399:arm-trusted-firmware-rockchip
+  PKG_BUILD_DEPENDS:=arm-trusted-firmware-rockchip
+  ATF:=rk3399_bl31.elf
+endef
+
 define U-Boot/rock-pi-4-rk3399
   BUILD_SUBTARGET:=armv8
   NAME:=Rock Pi 4
@@ -59,6 +70,7 @@ define U-Boot/rockpro64-rk3399
 endef
 
 UBOOT_TARGETS := \
+  nanopi-r4s-rk3399 \
   rock-pi-4-rk3399 \
   rockpro64-rk3399 \
   nanopi-r2s-rk3328
@@ -85,8 +97,15 @@ endef
 
 define Build/InstallDev
 	$(INSTALL_DIR) $(STAGING_DIR_IMAGE)
+ifneq ($(USE_RKBIN),)
+	$(STAGING_DIR_IMAGE)/loaderimage --pack --uboot $(PKG_BUILD_DIR)/u-boot-dtb.bin $(PKG_BUILD_DIR)/uboot.img 0x200000
+	$(CP) $(PKG_BUILD_DIR)/uboot.img $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-uboot.img
+	$(CP) $(STAGING_DIR_IMAGE)/idbloader.bin $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-idbloader.bin
+	$(CP) $(STAGING_DIR_IMAGE)/trust.bin $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-trust.bin
+else
 	$(CP) $(PKG_BUILD_DIR)/idbloader.img $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-idbloader.img
 	$(CP) $(PKG_BUILD_DIR)/u-boot.itb $(STAGING_DIR_IMAGE)/$(BUILD_VARIANT)-u-boot.itb
+endif
 endef
 
 define Package/u-boot/install/default
diff --git a/package/boot/uboot-rockchip/patches/200-rockchip-rk3399-split-nanopi-r4-rk3399-out-of-evb_rk.patch b/package/boot/uboot-rockchip/patches/200-rockchip-rk3399-split-nanopi-r4-rk3399-out-of-evb_rk.patch
new file mode 100644
index 0000000000..d8a118dd2e
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/200-rockchip-rk3399-split-nanopi-r4-rk3399-out-of-evb_rk.patch
@@ -0,0 +1,509 @@
+From a765bb2678b6d1666caafef0fcf88fba88b5b26f Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Fri, 18 Dec 2020 17:10:35 +0800
+Subject: [PATCH] rockchip: rk3399: split nanopi-r4-rk3399 out of evb_rk3399
+
+nanopi-r4-rk3399 board has multiple DDR types. Currently we don't have any code
+are compatible with these devices. Since multiple DDR types is specific to
+nanopi-r4-rk3399 board, split it into its own board file and add code
+support here.
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+[Improved commit message and Kconfig description]
+Signed-off-by: Tianling Shen <cnsztl@gmail.com>
+---
+ arch/arm/mach-rockchip/rk3399/Kconfig |  15 +++
+ board/friendlyarm/nanopi4/Kconfig     |  15 +++
+ board/friendlyarm/nanopi4/MAINTAINERS |   5 +
+ board/friendlyarm/nanopi4/Makefile    |   8 ++
+ board/friendlyarm/nanopi4/hwrev.c     | 185 ++++++++++++++++++++++++++
+ board/friendlyarm/nanopi4/hwrev.h     |  27 ++++
+ board/friendlyarm/nanopi4/nanopi4.c   | 148 +++++++++++++++++++++
+ drivers/clk/rockchip/clk_rk3399.c     |   2 +
+ include/configs/nanopi4.h             |  24 ++++
+ 9 files changed, 429 insertions(+)
+ create mode 100644 board/friendlyarm/nanopi4/Kconfig
+ create mode 100644 board/friendlyarm/nanopi4/MAINTAINERS
+ create mode 100644 board/friendlyarm/nanopi4/Makefile
+ create mode 100644 board/friendlyarm/nanopi4/hwrev.c
+ create mode 100644 board/friendlyarm/nanopi4/hwrev.h
+ create mode 100644 board/friendlyarm/nanopi4/nanopi4.c
+ create mode 100644 include/configs/nanopi4.h
+
+--- a/arch/arm/mach-rockchip/rk3399/Kconfig
++++ b/arch/arm/mach-rockchip/rk3399/Kconfig
+@@ -109,6 +109,20 @@ config TARGET_ROC_PC_RK3399
+ 	   * wide voltage input(5V-15V), dual cell battery
+ 	   * Wifi/BT accessible via expansion board M.2
+ 
++config TARGET_NANOPI4_RK3399
++	bool "FriendlyElec NanoPi4 board"
++	help
++	  NanoPi4 is SBC produced by FriendlyElec. Key features:
++
++	   * Rockchip RK3399
++	   * 1/2/4GB Dual-Channel DDR3/LPDDR4
++	   * SD card slot
++	   * Gigabit ethernet
++	   * PCIe
++	   * USB 3.0, 2.0
++	   * USB Type C power
++	   * GPIO expansion ports
++
+ endchoice
+ 
+ config ROCKCHIP_BOOT_MODE_REG
+@@ -152,6 +166,7 @@ config SYS_BOOTCOUNT_ADDR
+ endif # BOOTCOUNT_LIMIT
+ 
+ source "board/firefly/roc-pc-rk3399/Kconfig"
++source "board/friendlyarm/nanopi4/Kconfig"
+ source "board/google/gru/Kconfig"
+ source "board/pine64/pinebook-pro-rk3399/Kconfig"
+ source "board/pine64/rockpro64_rk3399/Kconfig"
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/Kconfig
+@@ -0,0 +1,15 @@
++if TARGET_NANOPI4_RK3399
++
++config SYS_BOARD
++	default "nanopi4"
++
++config SYS_VENDOR
++	default "friendlyarm"
++
++config SYS_CONFIG_NAME
++	default "nanopi4"
++
++config BOARD_SPECIFIC_OPTIONS
++	def_bool y
++
++endif
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/MAINTAINERS
+@@ -0,0 +1,5 @@
++NanoPi 4 Series
++M:      FriendlyElec <support@friendlyarm.com>
++S:      Maintained
++F:      board/friendlyarm/nanopi4/
++F:      include/configs/nanopi4.h
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/Makefile
+@@ -0,0 +1,8 @@
++#
++# Copyright (C) Guangzhou FriendlyELEC Computer Tech. Co., Ltd.
++# (http://www.friendlyarm.com)
++#
++# SPDX-License-Identifier:     GPL-2.0+
++#
++
++obj-y	+= nanopi4.o hwrev.o
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/hwrev.c
+@@ -0,0 +1,185 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Copyright (c) 2020 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ */
++
++#include <common.h>
++#include <dm.h>
++#include <linux/delay.h>
++#include <log.h>
++#include <asm/io.h>
++#include <asm/gpio.h>
++#include <asm/arch-rockchip/gpio.h>
++
++/*
++ * ID info:
++ *  ID : Volts : ADC value :   Bucket
++ *  ==   =====   =========   ===========
++ *   0 : 0.102V:        58 :    0 -   81
++ *   1 : 0.211V:       120 :   82 -  150
++ *   2 : 0.319V:       181 :  151 -  211
++ *   3 : 0.427V:       242 :  212 -  274
++ *   4 : 0.542V:       307 :  275 -  342
++ *   5 : 0.666V:       378 :  343 -  411
++ *   6 : 0.781V:       444 :  412 -  477
++ *   7 : 0.900V:       511 :  478 -  545
++ *   8 : 1.023V:       581 :  546 -  613
++ *   9 : 1.137V:       646 :  614 -  675
++ *  10 : 1.240V:       704 :  676 -  733
++ *  11 : 1.343V:       763 :  734 -  795
++ *  12 : 1.457V:       828 :  796 -  861
++ *  13 : 1.576V:       895 :  862 -  925
++ *  14 : 1.684V:       956 :  926 -  989
++ *  15 : 1.800V:      1023 :  990 - 1023
++ */
++static const int id_readings[] = {
++	 81, 150, 211, 274, 342, 411, 477, 545,
++	613, 675, 733, 795, 861, 925, 989, 1023
++};
++
++static int cached_board_id = -1;
++
++#define SARADC_BASE		0xFF100000
++#define SARADC_DATA		(SARADC_BASE + 0)
++#define SARADC_CTRL		(SARADC_BASE + 8)
++
++static u32 get_saradc_value(int chn)
++{
++	int timeout = 0;
++	u32 adc_value = 0;
++
++	writel(0, SARADC_CTRL);
++	udelay(2);
++
++	writel(0x28 | chn, SARADC_CTRL);
++	udelay(50);
++
++	timeout = 0;
++	do {
++		if (readl(SARADC_CTRL) & 0x40) {
++			adc_value = readl(SARADC_DATA) & 0x3FF;
++			goto stop_adc;
++		}
++
++		udelay(10);
++	} while (timeout++ < 100);
++
++stop_adc:
++	writel(0, SARADC_CTRL);
++
++	return adc_value;
++}
++
++static uint32_t get_adc_index(int chn)
++{
++	int i;
++	int adc_reading;
++
++	if (cached_board_id != -1)
++		return cached_board_id;
++
++	adc_reading = get_saradc_value(chn);
++	for (i = 0; i < ARRAY_SIZE(id_readings); i++) {
++		if (adc_reading <= id_readings[i]) {
++			debug("ADC reading %d, ID %d\n", adc_reading, i);
++			cached_board_id = i;
++			return i;
++		}
++	}
++
++	/* should die for impossible value */
++	return 0;
++}
++
++/*
++ * Board revision list: <GPIO4_D1 | GPIO4_D0>
++ *  0b00 - NanoPC-T4
++ *  0b01 - NanoPi M4
++ *
++ * Extended by ADC_IN4
++ * Group A:
++ *  0x04 - NanoPi NEO4
++ *  0x06 - SOC-RK3399
++ *  0x07 - SOC-RK3399 V2
++ *  0x09 - NanoPi R4S 1GB
++ *  0x0A - NanoPi R4S 4GB
++ *
++ * Group B:
++ *  0x21 - NanoPi M4 Ver2.0
++ *  0x22 - NanoPi M4B
++ */
++static int pcb_rev = -1;
++
++void bd_hwrev_init(void)
++{
++#define GPIO4_BASE	0xff790000
++	struct rockchip_gpio_regs *regs = (void *)GPIO4_BASE;
++
++#ifdef CONFIG_SPL_BUILD
++	struct udevice *dev;
++
++	if (uclass_get_device_by_driver(UCLASS_CLK,
++				DM_GET_DRIVER(clk_rk3399), &dev))
++		return;
++#endif
++
++	if (pcb_rev >= 0)
++		return;
++
++	/* D1, D0: input mode */
++	clrbits_le32(&regs->swport_ddr, (0x3 << 24));
++	pcb_rev = (readl(&regs->ext_port) >> 24) & 0x3;
++
++	if (pcb_rev == 0x3) {
++		/* Revision group A: 0x04 ~ 0x13 */
++		pcb_rev = 0x4 + get_adc_index(4);
++
++	} else if (pcb_rev == 0x1) {
++		int idx = get_adc_index(4);
++
++		/* Revision group B: 0x21 ~ 0x2f */
++		if (idx > 0) {
++			pcb_rev = 0x20 + idx;
++		}
++	}
++}
++
++#ifdef CONFIG_SPL_BUILD
++static struct board_ddrtype {
++	int rev;
++	const char *type;
++} ddrtypes[] = {
++	{ 0x00, "lpddr3-samsung-4GB-1866" },
++	{ 0x01, "lpddr3-samsung-4GB-1866" },
++	{ 0x04,   "ddr3-1866" },
++	{ 0x06,   "ddr3-1866" },
++	{ 0x07, "lpddr4-100"  },
++	{ 0x09,   "ddr3-1866" },
++	{ 0x0a, "lpddr4-100"  },
++	{ 0x21, "lpddr4-100"  },
++	{ 0x22,   "ddr3-1866" },
++};
++
++const char *rk3399_get_ddrtype(void) {
++	int i;
++
++	bd_hwrev_init();
++	printf("Board: rev%02x\n", pcb_rev);
++
++	for (i = 0; i < ARRAY_SIZE(ddrtypes); i++) {
++		if (ddrtypes[i].rev == pcb_rev)
++			return ddrtypes[i].type;
++	}
++
++	/* fallback to first subnode (ie, first included dtsi) */
++	return NULL;
++}
++#endif
++
++/* To override __weak symbols */
++u32 get_board_rev(void)
++{
++	return pcb_rev;
++}
++
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/hwrev.h
+@@ -0,0 +1,27 @@
++/*
++ * Copyright (C) Guangzhou FriendlyARM Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, you can access it online at
++ * http://www.gnu.org/licenses/gpl-2.0.html.
++ */
++
++#ifndef __BD_HW_REV_H__
++#define __BD_HW_REV_H__
++
++extern void bd_hwrev_config_gpio(void);
++extern void bd_hwrev_init(void);
++extern u32 get_board_rev(void);
++
++#endif /* __BD_HW_REV_H__ */
+--- /dev/null
++++ b/board/friendlyarm/nanopi4/nanopi4.c
+@@ -0,0 +1,148 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Copyright (c) 2020 FriendlyElec Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ */
++
++#include <common.h>
++#include <dm.h>
++#include <env.h>
++#include <hash.h>
++#include <linux/bitops.h>
++#include <i2c.h>
++#include <init.h>
++#include <net.h>
++#include <netdev.h>
++#include <syscon.h>
++#include <asm/arch-rockchip/bootrom.h>
++#include <asm/arch-rockchip/clock.h>
++#include <asm/arch-rockchip/grf_rk3399.h>
++#include <asm/arch-rockchip/hardware.h>
++#include <asm/arch-rockchip/misc.h>
++#include <asm/io.h>
++#include <asm/setup.h>
++#include <u-boot/sha256.h>
++
++#ifdef CONFIG_MISC_INIT_R
++static void setup_iodomain(void)
++{
++	struct rk3399_grf_regs *grf =
++	    syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
++
++	/* BT565 and AUDIO is in 1.8v domain */
++	rk_setreg(&grf->io_vsel, BIT(0) | BIT(1));
++}
++
++static int __maybe_unused mac_read_from_generic_eeprom(u8 *addr)
++{
++	struct udevice *i2c_dev;
++	int ret;
++
++	/* Microchip 24AA02xxx EEPROMs with EUI-48 Node Identity */
++	ret = i2c_get_chip_for_busnum(2, 0x51, 1, &i2c_dev);
++	if (!ret)
++		ret = dm_i2c_read(i2c_dev, 0xfa, addr, 6);
++
++	return ret;
++}
++
++static void setup_macaddr(void)
++{
++#if CONFIG_IS_ENABLED(CMD_NET)
++	int ret;
++	const char *cpuid = env_get("cpuid#");
++	u8 hash[SHA256_SUM_LEN];
++	int size = sizeof(hash);
++	u8 mac_addr[6];
++	int from_eeprom = 0;
++	int lockdown = 0;
++
++#ifndef CONFIG_ENV_IS_NOWHERE
++	lockdown = env_get_yesno("lockdown") == 1;
++#endif
++	if (lockdown && env_get("ethaddr"))
++		return;
++
++	ret = mac_read_from_generic_eeprom(mac_addr);
++	if (!ret && is_valid_ethaddr(mac_addr)) {
++		eth_env_set_enetaddr("ethaddr", mac_addr);
++		from_eeprom = 1;
++	}
++
++	if (!cpuid) {
++		debug("%s: could not retrieve 'cpuid#'\n", __func__);
++		return;
++	}
++
++	ret = hash_block("sha256", (void *)cpuid, strlen(cpuid), hash, &size);
++	if (ret) {
++		debug("%s: failed to calculate SHA256\n", __func__);
++		return;
++	}
++
++	/* Copy 6 bytes of the hash to base the MAC address on */
++	memcpy(mac_addr, hash, 6);
++
++	/* Make this a valid MAC address and set it */
++	mac_addr[0] &= 0xfe;  /* clear multicast bit */
++	mac_addr[0] |= 0x02;  /* set local assignment bit (IEEE802) */
++
++	if (from_eeprom) {
++		eth_env_set_enetaddr("eth1addr", mac_addr);
++	} else {
++		eth_env_set_enetaddr("ethaddr", mac_addr);
++
++		if (lockdown && env_get("eth1addr"))
++			return;
++
++		/* Ugly, copy another 4 bytes to generate a similar address */
++		memcpy(mac_addr + 2, hash + 8, 4);
++		if (!memcmp(hash + 2, hash + 8, 4))
++			mac_addr[5] ^= 0xff;
++
++		eth_env_set_enetaddr("eth1addr", mac_addr);
++	}
++#endif
++
++	return;
++}
++
++int misc_init_r(void)
++{
++	const u32 cpuid_offset = 0x7;
++	const u32 cpuid_length = 0x10;
++	u8 cpuid[cpuid_length];
++	int ret;
++
++	setup_iodomain();
++
++	ret = rockchip_cpuid_from_efuse(cpuid_offset, cpuid_length, cpuid);
++	if (ret)
++		return ret;
++
++	ret = rockchip_cpuid_set(cpuid, cpuid_length);
++	if (ret)
++		return ret;
++
++	setup_macaddr();
++	bd_hwrev_init();
++
++	return 0;
++}
++#endif
++
++#ifdef CONFIG_SERIAL_TAG
++void get_board_serial(struct tag_serialnr *serialnr)
++{
++	char *serial_string;
++	u64 serial = 0;
++
++	serial_string = env_get("serial#");
++
++	if (serial_string)
++		serial = simple_strtoull(serial_string, NULL, 16);
++
++	serialnr->high = (u32)(serial >> 32);
++	serialnr->low = (u32)(serial & 0xffffffff);
++}
++#endif
+diff --git a/drivers/clk/rockchip/clk_rk3399.c b/drivers/clk/rockchip/clk_rk3399.c
+index 22c373a623..38975c0c65 100644
+--- a/drivers/clk/rockchip/clk_rk3399.c
++++ b/drivers/clk/rockchip/clk_rk3399.c
+@@ -1351,6 +1351,8 @@ static void rkclk_init(struct rockchip_cru *cru)
+ 		     pclk_div << PCLK_PERILP1_DIV_CON_SHIFT |
+ 		     hclk_div << HCLK_PERILP1_DIV_CON_SHIFT |
+ 		     HCLK_PERILP1_PLL_SEL_GPLL << HCLK_PERILP1_PLL_SEL_SHIFT);
++
++	rk3399_saradc_set_clk(cru, 1000000);
+ }
+ #endif
+ 
+--- /dev/null
++++ b/include/configs/nanopi4.h
+@@ -0,0 +1,24 @@
++/* SPDX-License-Identifier: GPL-2.0+ */
++/*
++ * Copyright (C) Guangzhou FriendlyELEC Computer Tech. Co., Ltd.
++ * (http://www.friendlyarm.com)
++ *
++ * (C) Copyright 2016 Rockchip Electronics Co., Ltd
++ */
++
++#ifndef __CONFIG_NANOPI4_H__
++#define __CONFIG_NANOPI4_H__
++
++#define ROCKCHIP_DEVICE_SETTINGS \
++		"stdin=serial,usbkbd\0" \
++		"stdout=serial,vidconsole\0" \
++		"stderr=serial,vidconsole\0"
++
++#include <configs/rk3399_common.h>
++
++#define SDRAM_BANK_SIZE			(2UL << 30)
++
++#define CONFIG_SERIAL_TAG
++#define CONFIG_REVISION_TAG
++
++#endif
diff --git a/package/boot/uboot-rockchip/patches/201-ram-rk3399-Add-support-for-multiple-DDR-types.patch b/package/boot/uboot-rockchip/patches/201-ram-rk3399-Add-support-for-multiple-DDR-types.patch
new file mode 100644
index 0000000000..b624bcc763
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/201-ram-rk3399-Add-support-for-multiple-DDR-types.patch
@@ -0,0 +1,256 @@
+From a9447b7b60a3c5195d0fabbe5aa9c32d047ec997 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Sat, 19 Dec 2020 19:39:14 +0800
+Subject: [PATCH] ram: rk3399: Add support for multiple DDR types
+
+Move rockchip,sdram-params to named subnode to include
+multiple sdram parameters, and then read the parameters
+(by subnode name, first subnode or current node) before
+rk3399_dmc_init().
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ arch/arm/dts/rk3399-sdram-ddr3-1333.dtsi      |  6 ++-
+ arch/arm/dts/rk3399-sdram-ddr3-1600.dtsi      |  5 +-
+ arch/arm/dts/rk3399-sdram-ddr3-1866.dtsi      |  6 ++-
+ .../arm/dts/rk3399-sdram-lpddr3-2GB-1600.dtsi |  3 ++
+ .../arm/dts/rk3399-sdram-lpddr3-4GB-1600.dtsi |  3 ++
+ .../rk3399-sdram-lpddr3-samsung-4GB-1866.dtsi |  3 ++
+ arch/arm/dts/rk3399-sdram-lpddr4-100.dtsi     |  3 ++
+ drivers/ram/rockchip/sdram_rk3399.c           | 49 +++++++++++++++----
+ 8 files changed, 64 insertions(+), 14 deletions(-)
+
+--- a/arch/arm/dts/rk3399-sdram-ddr3-1333.dtsi
++++ b/arch/arm/dts/rk3399-sdram-ddr3-1333.dtsi
+@@ -4,7 +4,9 @@
+  */
+ 
+ &dmc {
+-        rockchip,sdram-params = <
++	ddr3-1333 {
++	u-boot,dm-pre-reloc;
++	rockchip,sdram-params = <
+ 		0x1
+ 		0xa
+ 		0x3
+@@ -1536,5 +1538,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+-
+--- a/arch/arm/dts/rk3399-sdram-ddr3-1600.dtsi
++++ b/arch/arm/dts/rk3399-sdram-ddr3-1600.dtsi
+@@ -4,7 +4,9 @@
+  */
+ 
+ &dmc {
+-        rockchip,sdram-params = <
++	ddr3-1600 {
++	u-boot,dm-pre-reloc;
++	rockchip,sdram-params = <
+ 		0x1
+ 		0xa
+ 		0x3
+@@ -1536,4 +1538,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+--- a/arch/arm/dts/rk3399-sdram-ddr3-1866.dtsi
++++ b/arch/arm/dts/rk3399-sdram-ddr3-1866.dtsi
+@@ -4,7 +4,9 @@
+  */
+ 
+ &dmc {
+-        rockchip,sdram-params = <
++	ddr3-1866 {
++	u-boot,dm-pre-reloc;
++	rockchip,sdram-params = <
+ 		0x1
+ 		0xa
+ 		0x3
+@@ -1536,5 +1538,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+-
+--- a/arch/arm/dts/rk3399-sdram-lpddr3-2GB-1600.dtsi
++++ b/arch/arm/dts/rk3399-sdram-lpddr3-2GB-1600.dtsi
+@@ -5,6 +5,8 @@
+  */
+ 
+ &dmc {
++	lpddr3-2GB-1600 {
++	u-boot,dm-pre-reloc;
+ 	rockchip,sdram-params = <
+ 		0x1
+ 		0xa
+@@ -1537,4 +1539,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+--- a/arch/arm/dts/rk3399-sdram-lpddr3-4GB-1600.dtsi
++++ b/arch/arm/dts/rk3399-sdram-lpddr3-4GB-1600.dtsi
+@@ -4,6 +4,8 @@
+  */
+ 
+ &dmc {
++	lpddr3-4GB-1600 {
++	u-boot,dm-pre-reloc;
+ 	rockchip,sdram-params = <
+ 		0x2
+ 		0xa
+@@ -1536,4 +1538,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+--- a/arch/arm/dts/rk3399-sdram-lpddr3-samsung-4GB-1866.dtsi
++++ b/arch/arm/dts/rk3399-sdram-lpddr3-samsung-4GB-1866.dtsi
+@@ -4,6 +4,8 @@
+  */
+ 
+ &dmc {
++	lpddr3-samsung-4GB-1866 {
++	u-boot,dm-pre-reloc;
+ 	rockchip,sdram-params = <
+ 		0x2
+ 		0xa
+@@ -1543,4 +1545,5 @@
+ 		0x01010000	/* DENALI_PHY_957_DATA */
+ 		0x00000000	/* DENALI_PHY_958_DATA */
+ 	>;
++	};
+ };
+--- a/arch/arm/dts/rk3399-sdram-lpddr4-100.dtsi
++++ b/arch/arm/dts/rk3399-sdram-lpddr4-100.dtsi
+@@ -6,6 +6,8 @@
+  */
+ 
+ &dmc {
++	lpddr4-100 {
++	u-boot,dm-pre-reloc;
+ 	rockchip,sdram-params = <
+ 		0x2
+ 		0xa
+@@ -1538,4 +1540,5 @@
+ 		0x01010000
+ 		0x00000000
+ 	>;
++	};
+ };
+--- a/drivers/ram/rockchip/sdram_rk3399.c
++++ b/drivers/ram/rockchip/sdram_rk3399.c
+@@ -1625,7 +1625,6 @@ static void set_ddr_stride(struct rk3399_pmusgrf_regs *pmusgrf, u32 stride)
+ 	rk_clrsetreg(&pmusgrf->soc_con4, 0x1f << 10, stride << 10);
+ }
+ 
+-#if !defined(CONFIG_RAM_RK3399_LPDDR4)
+ static int data_training_first(struct dram_info *dram, u32 channel, u8 rank,
+ 			       struct rk3399_sdram_params *params)
+ {
+@@ -1715,8 +1714,8 @@ void modify_param(const struct chan_info *chan,
+ 	clrsetbits_le32(&denali_pi_params[76], 0x1 << 24, 0x1 << 24);
+ 	clrsetbits_le32(&denali_pi_params[77], 0x1, 0x1);
+ }
+-#else
+ 
++#if defined(CONFIG_RAM_RK3399_LPDDR4)
+ struct rk3399_sdram_params dfs_cfgs_lpddr4[] = {
+ #include "sdram-rk3399-lpddr4-400.inc"
+ #include "sdram-rk3399-lpddr4-800.inc"
+@@ -3011,20 +3010,40 @@ static int sdram_init(struct dram_info *dram,
+ 	return 0;
+ }
+ 
++__weak const char *rk3399_get_ddrtype(void)
++{
++	return NULL;
++}
++
+ static int rk3399_dmc_ofdata_to_platdata(struct udevice *dev)
+ {
+ #if !CONFIG_IS_ENABLED(OF_PLATDATA)
+ 	struct rockchip_dmc_plat *plat = dev_get_platdata(dev);
++	ofnode node = { .np = NULL };
++	const char *name;
+ 	int ret;
+ 
+-	ret = dev_read_u32_array(dev, "rockchip,sdram-params",
+-				 (u32 *)&plat->sdram_params,
+-				 sizeof(plat->sdram_params) / sizeof(u32));
++	name = rk3399_get_ddrtype();
++	if (name)
++		node = dev_read_subnode(dev, name);
++	if (!ofnode_valid(node)) {
++		debug("Failed to read subnode %s\n", name);
++		node = dev_read_first_subnode(dev);
++	}
++
++	/* fallback to current node */
++	if (!ofnode_valid(node))
++		node = dev_ofnode(dev);
++
++	ret = ofnode_read_u32_array(node, "rockchip,sdram-params",
++				    (u32 *)&plat->sdram_params,
++				    sizeof(plat->sdram_params) / sizeof(u32));
+ 	if (ret) {
+ 		printf("%s: Cannot read rockchip,sdram-params %d\n",
+ 		       __func__, ret);
+ 		return ret;
+ 	}
++
+ 	ret = regmap_init_mem(dev_ofnode(dev), &plat->map);
+ 	if (ret)
+ 		printf("%s: regmap failed %d\n", __func__, ret);
+@@ -3051,18 +3070,20 @@ static int conv_of_platdata(struct udevice *dev)
+ #endif
+ 
+ static const struct sdram_rk3399_ops rk3399_ops = {
+-#if !defined(CONFIG_RAM_RK3399_LPDDR4)
+ 	.data_training_first = data_training_first,
+ 	.set_rate_index = switch_to_phy_index1,
+ 	.modify_param = modify_param,
+ 	.get_phy_index_params = get_phy_index_params,
+-#else
++};
++
++#if defined(CONFIG_RAM_RK3399_LPDDR4)
++static const struct sdram_rk3399_ops lpddr4_ops = {
+ 	.data_training_first = lpddr4_mr_detect,
+ 	.set_rate_index = lpddr4_set_rate,
+ 	.modify_param = lpddr4_modify_param,
+ 	.get_phy_index_params = lpddr4_get_phy_index_params,
+-#endif
+ };
++#endif
+ 
+ static int rk3399_dmc_init(struct udevice *dev)
+ {
+@@ -3081,7 +3102,17 @@ static int rk3399_dmc_init(struct udevice *dev)
+ 		return ret;
+ #endif
+ 
+-	priv->ops = &rk3399_ops;
++	if (params->base.dramtype == LPDDR4) {
++#if defined(CONFIG_RAM_RK3399_LPDDR4)
++		priv->ops = &lpddr4_ops;
++#else
++		printf("LPDDR4 support is disable\n");
++		return -EINVAL;
++#endif
++	} else {
++		priv->ops = &rk3399_ops;
++	}
++
+ 	priv->cic = syscon_get_first_range(ROCKCHIP_SYSCON_CIC);
+ 	priv->grf = syscon_get_first_range(ROCKCHIP_SYSCON_GRF);
+ 	priv->pmu = syscon_get_first_range(ROCKCHIP_SYSCON_PMU);
diff --git a/package/boot/uboot-rockchip/patches/202-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch b/package/boot/uboot-rockchip/patches/202-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
new file mode 100644
index 0000000000..74c7c3f4a5
--- /dev/null
+++ b/package/boot/uboot-rockchip/patches/202-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
@@ -0,0 +1,313 @@
+From 8dc76bbce30c3f63f290f008f8410c00fee13c9a Mon Sep 17 00:00:00 2001
+From: Tianling Shen <cnsztl@gmail.com>
+Date: Fri, 8 Jan 2021 05:55:50 +0000
+Subject: [PATCH] rockchip: rk3399: Add support for FriendlyARM NanoPi R4S
+
+This adds support for the NanoPi R4S from FriendlyArm.
+
+Rockchip RK3399 SoC
+1GB DDR3 or 4GB LPDDR4 RAM
+Gigabit Ethernet (WAN)
+Gigabit Ethernet (PCIe) (LAN)
+USB 3.0 Host Port x 2
+MicroSD slot
+Reset button
+WAN - LAN - SYS LED
+
+Signed-off-by: Tianling Shen <cnsztl@gmail.com>
+Co-authored-by: Jensen Huang <jensenhuang@friendlyarm.com>
+Signed-off-by: Jensen Huang <jensenhuang@friendlyarm.com>
+Co-authored-by: Marty Jones <mj8263788@gmail.com>
+Signed-off-by: Marty Jones <mj8263788@gmail.com>
+---
+ arch/arm/dts/Makefile                      |   1 +
+ arch/arm/dts/rk3399-nanopi-r4s-u-boot.dtsi |   9 ++
+ arch/arm/dts/rk3399-nanopi-r4s.dts         | 178 +++++++++++++++++++++
+ board/friendlyarm/nanopi4/MAINTAINERS      |   6 +
+ configs/nanopi-r4s-rk3399_defconfig        |  63 ++++++++
+ 5 files changed, 257 insertions(+)
+ create mode 100644 arch/arm/dts/rk3399-nanopi-r4s-u-boot.dtsi
+ create mode 100644 arch/arm/dts/rk3399-nanopi-r4s.dts
+ create mode 100644 configs/nanopi-r4s-rk3399_defconfig
+
+--- a/arch/arm/dts/Makefile
++++ b/arch/arm/dts/Makefile
+@@ -132,6 +132,7 @@ dtb-$(CONFIG_ROCKCHIP_RK3399) += \
+ 	rk3399-nanopi-m4.dtb \
+ 	rk3399-nanopi-m4-2gb.dtb \
+ 	rk3399-nanopi-neo4.dtb \
++	rk3399-nanopi-r4s.dtb \
+ 	rk3399-orangepi.dtb \
+ 	rk3399-pinebook-pro.dtb \
+ 	rk3399-puma-haikou.dtb \
+--- /dev/null
++++ b/arch/arm/dts/rk3399-nanopi-r4s-u-boot.dtsi
+@@ -0,0 +1,9 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * (C) Copyright 2020 Jensen Huang <jensenhuang@friendlyarm.com>
++ */
++
++#include "rk3399-nanopi4-u-boot.dtsi"
++#include "rk3399-sdram-lpddr4-100.dtsi"
++#include "rk3399-sdram-lpddr3-samsung-4GB-1866.dtsi"
++#include "rk3399-sdram-ddr3-1866.dtsi"
+--- /dev/null
++++ b/arch/arm/dts/rk3399-nanopi-r4s.dts
+@@ -0,0 +1,178 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2020 Jensen Huang <jensenhuang@friendlyarm.com>
++ * Copyright (c) 2020 Marty Jones <mj8263788@gmail.com>
++ * Copyright (c) 2020 Tianling Shen <cnsztl@gmail.com>
++ */
++
++/dts-v1/;
++#include "rk3399-nanopi4.dtsi"
++
++/ {
++	model = "FriendlyElec NanoPi R4S";
++	compatible = "friendlyarm,nanopi-r4s", "rockchip,rk3399";
++
++	aliases {
++		led-boot = &sys_led;
++		led-failsafe = &sys_led;
++		led-running = &sys_led;
++		led-upgrade = &sys_led;
++	};
++
++	/delete-node/ gpio-leds;
++	gpio-leds {
++		compatible = "gpio-leds";
++		pinctrl-0 = <&lan_led_pin>, <&sys_led_pin>, <&wan_led_pin>;
++		pinctrl-names = "default";
++
++		lan_led: led-0 {
++			gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:green:lan";
++		};
++
++		sys_led: led-1 {
++			gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:red:sys";
++		};
++
++		wan_led: led-2 {
++			gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:green:wan";
++		};
++	};
++
++	/delete-node/ gpio-keys;
++	gpio-keys {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&reset_button_pin>;
++
++		reset {
++			debounce-interval = <50>;
++			gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_LOW>;
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++		};
++	};
++
++	vdd_5v: vdd-5v {
++		compatible = "regulator-fixed";
++		regulator-name = "vdd_5v";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	fan: pwm-fan {
++		compatible = "pwm-fan";
++		/*
++		 * With 20KHz PWM and an EVERCOOL EC4007H12SA fan, these levels
++		 * work out to 0, ~1200, ~3000, and 5000RPM respectively.
++		 */
++		cooling-levels = <0 12 18 255>;
++		#cooling-cells = <2>;
++		fan-supply = <&vdd_5v>;
++		pwms = <&pwm1 0 50000 0>;
++	};
++};
++
++&cpu_thermal {
++	trips {
++		cpu_warm: cpu_warm {
++			temperature = <55000>;
++			hysteresis = <2000>;
++			type = "active";
++		};
++
++		cpu_hot: cpu_hot {
++			temperature = <65000>;
++			hysteresis = <2000>;
++			type = "active";
++		};
++	};
++
++	cooling-maps {
++		map2 {
++			trip = <&cpu_warm>;
++			cooling-device = <&fan THERMAL_NO_LIMIT 1>;
++		};
++
++		map3 {
++			trip = <&cpu_hot>;
++			cooling-device = <&fan 2 THERMAL_NO_LIMIT>;
++		};
++	};
++};
++
++&emmc_phy {
++	status = "disabled";
++};
++
++&fusb0 {
++	status = "disabled";
++};
++
++&pcie0 {
++	max-link-speed = <1>;
++	num-lanes = <1>;
++	vpcie3v3-supply = <&vcc3v3_sys>;
++
++	pcie@0 {
++		reg = <0x00000000 0 0 0 0>;
++		#address-cells = <3>;
++		#size-cells = <2>;
++	};
++};
++
++&pinctrl {
++	/delete-node/ gpio-leds;
++	gpio-leds {
++		lan_led_pin: lan-led-pin {
++			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		sys_led_pin: sys-led-pin {
++			rockchip,pins = <0 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		wan_led_pin: wan-led-pin {
++			rockchip,pins = <1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	/delete-node/ rockchip-key;
++	rockchip-key {
++		reset_button_pin: reset-button-pin {
++			rockchip,pins = <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++};
++
++&sdhci {
++	status = "disabled";
++};
++
++&sdio0 {
++	status = "disabled";
++};
++
++&sdmmc {
++	sd-uhs-sdr12;
++	sd-uhs-sdr25;
++	sd-uhs-sdr50;
++};
++
++&u2phy0_host {
++	phy-supply = <&vdd_5v>;
++};
++
++&u2phy1_host {
++	status = "disabled";
++};
++
++&usbdrd_dwc3_0 {
++	dr_mode = "host";
++};
++
++&vcc3v3_sys {
++	vin-supply = <&vcc5v0_sys>;
++};
+--- a/board/friendlyarm/nanopi4/MAINTAINERS
++++ b/board/friendlyarm/nanopi4/MAINTAINERS
+@@ -3,3 +3,9 @@ M:      FriendlyElec <support@friendlyarm.com>
+ S:      Maintained
+ F:      board/friendlyarm/nanopi4/
+ F:      include/configs/nanopi4.h
++
++NANOPI-R4S
++M:      Tianling Shen <cnsztl@gmail.com>
++S:      Maintained
++F:      configs/nanopi-r4s-rk3399_defconfig
++F:      arch/arm/dts/rk3399-nanopi-r4s-u-boot.dtsi
+--- /dev/null
++++ b/configs/nanopi-r4s-rk3399_defconfig
+@@ -0,0 +1,63 @@
++CONFIG_ARM=y
++CONFIG_ARCH_ROCKCHIP=y
++CONFIG_SYS_TEXT_BASE=0x00200000
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_ENV_OFFSET=0x3F8000
++CONFIG_ROCKCHIP_RK3399=y
++CONFIG_TARGET_NANOPI4_RK3399=y
++CONFIG_DEBUG_UART_BASE=0xFF1A0000
++CONFIG_DEBUG_UART_CLOCK=24000000
++CONFIG_DEFAULT_DEVICE_TREE="rk3399-nanopi-r4s"
++CONFIG_DEBUG_UART=y
++CONFIG_DEFAULT_FDT_FILE="rockchip/rk3399-nanopi-r4s.dtb"
++CONFIG_MISC_INIT_R=y
++# CONFIG_SPL_RAW_IMAGE_SUPPORT is not set
++CONFIG_SPL_STACK_R=y
++CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN=0x10000
++CONFIG_TPL=y
++CONFIG_CMD_BOOTZ=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_MMC=y
++CONFIG_CMD_USB=y
++# CONFIG_CMD_SETEXPR is not set
++CONFIG_CMD_TIME=y
++CONFIG_SPL_OF_CONTROL=y
++CONFIG_OF_SPL_REMOVE_PROPS="pinctrl-0 pinctrl-names clock-names interrupt-parent assigned-clocks assigned-clock-rates assigned-clock-parents"
++CONFIG_ENV_IS_IN_MMC=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_SYS_MMC_ENV_DEV=1
++CONFIG_ROCKCHIP_GPIO=y
++CONFIG_SYS_I2C_ROCKCHIP=y
++CONFIG_MMC_DW=y
++CONFIG_MMC_DW_ROCKCHIP=y
++CONFIG_MMC_SDHCI=y
++CONFIG_MMC_SDHCI_ROCKCHIP=y
++CONFIG_DM_ETH=y
++CONFIG_ETH_DESIGNWARE=y
++CONFIG_GMAC_ROCKCHIP=y
++CONFIG_PMIC_RK8XX=y
++CONFIG_REGULATOR_PWM=y
++CONFIG_REGULATOR_RK8XX=y
++CONFIG_PWM_ROCKCHIP=y
++CONFIG_RAM_RK3399_LPDDR4=y
++CONFIG_BAUDRATE=1500000
++CONFIG_DEBUG_UART_SHIFT=2
++CONFIG_SYSRESET=y
++CONFIG_USB=y
++CONFIG_USB_XHCI_HCD=y
++CONFIG_USB_XHCI_DWC3=y
++CONFIG_USB_EHCI_HCD=y
++CONFIG_USB_EHCI_GENERIC=y
++CONFIG_USB_KEYBOARD=y
++CONFIG_USB_HOST_ETHER=y
++CONFIG_USB_ETHER_ASIX=y
++CONFIG_USB_ETHER_ASIX88179=y
++CONFIG_USB_ETHER_MCS7830=y
++CONFIG_USB_ETHER_RTL8152=y
++CONFIG_USB_ETHER_SMSC95XX=y
++CONFIG_DM_VIDEO=y
++CONFIG_DISPLAY=y
++CONFIG_VIDEO_ROCKCHIP=y
++CONFIG_DISPLAY_ROCKCHIP_HDMI=y
++CONFIG_SPL_TINY_MEMSET=y
++CONFIG_ERRNO_STR=y
diff --git a/target/linux/generic/hack-5.10/310-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch b/target/linux/generic/hack-5.10/310-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch
new file mode 100644
index 0000000000..70cfadca9c
--- /dev/null
+++ b/target/linux/generic/hack-5.10/310-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch
@@ -0,0 +1,38 @@
+From: Sumit Gupta <sumitg@nvidia.com>
+To: <catalin.marinas@arm.com>, <linux-arm-kernel@lists.infradead.org>,
+	<linux-kernel@vger.kernel.org>
+Cc: <will.deacon@arm.com>, <suzuki.poulose@arm.com>,
+	<james.morse@arm.com>, <mark.rutland@arm.com>,
+	<yang.shi@linaro.org>, <julien.grall@arm.com>,
+	<steve.capper@linaro.org>, <bbasu@nvidia.com>,
+	<linux-tegra@vger.kernel.org>, Sumit Gupta <sumitg@nvidia.com>
+Subject: [PATCH] arm64: cpuinfo: Add "model name" in /proc/cpuinfo for 64bit tasks also
+Date: Mon, 29 Aug 2016 14:32:25 +0530
+Message-ID: <1472461345-28219-1-git-send-email-sumitg@nvidia.com> (raw)
+
+Removed restriction of displaying model name for 32 bit tasks only.
+Because of this Processor details were not displayed in
+"System setting -> Details" in Ubuntu model name display is generic
+and can be printed for 64 bit also.
+
+model name : ARMv8 Processor rev X (v8l)
+
+Signed-off-by: Sumit Gupta <sumitg@nvidia.com>
+---
+ arch/arm64/kernel/cpuinfo.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/arch/arm64/kernel/cpuinfo.c
++++ b/arch/arm64/kernel/cpuinfo.c
+@@ -148,9 +148,8 @@ static int c_show(struct seq_file *m, vo
+ 		 * "processor".  Give glibc what it expects.
+ 		 */
+ 		seq_printf(m, "processor\t: %d\n", i);
+-		if (compat)
+-			seq_printf(m, "model name\t: ARMv8 Processor rev %d (%s)\n",
+-				   MIDR_REVISION(midr), COMPAT_ELF_PLATFORM);
++		seq_printf(m, "model name\t: ARMv8 Processor rev %d (%s)\n",
++			   MIDR_REVISION(midr), COMPAT_ELF_PLATFORM);
+ 
+ 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+ 			   loops_per_jiffy / (500000UL/HZ),
diff --git a/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch b/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
new file mode 100644
index 0000000000..2981c3d906
--- /dev/null
+++ b/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
@@ -0,0 +1,291 @@
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -72,6 +72,10 @@ struct nf_ct_event {
+ 	int report;
+ };
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
++extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
++#else
+ struct nf_ct_event_notifier {
+ 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
+ };
+@@ -80,6 +84,7 @@ int nf_conntrack_register_notifier(struc
+ 				   struct nf_ct_event_notifier *nb);
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *nb);
++#endif
+ 
+ void nf_ct_deliver_cached_events(struct nf_conn *ct);
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+@@ -105,11 +110,13 @@ static inline void
+ nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return;
++#endif
+ 
+ 	e = nf_ct_ecache_find(ct);
+ 	if (e == NULL)
+@@ -124,10 +131,12 @@ nf_conntrack_event_report(enum ip_conntr
+ 			  u32 portid, int report)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
+ #else
+@@ -139,10 +148,12 @@ static inline int
+ nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
+ #else
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -112,7 +112,11 @@ struct netns_ct {
+ 
+ 	struct ct_pcpu __percpu *pcpu_lists;
+ 	struct ip_conntrack_stat __percpu *stat;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct atomic_notifier_head nf_conntrack_chain;
++#else
+ 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
++#endif
+ 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+ #if defined(CONFIG_NF_CONNTRACK_LABELS)
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -136,6 +136,14 @@ config NF_CONNTRACK_EVENTS
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_CHAIN_EVENTS
++	bool "Register multiple callbacks to ct events"
++	depends on NF_CONNTRACK_EVENTS
++	help
++	  Support multiple registrations.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMEOUT
+ 	bool  'Connection tracking timeout'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2748,6 +2748,9 @@ int nf_conntrack_init_net(struct net *ne
+ 	nf_conntrack_helper_pernet_init(net);
+ 	nf_conntrack_proto_pernet_init(net);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
++#endif
+ 	return 0;
+ 
+ err_expect:
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -17,6 +17,9 @@
+ #include <linux/stddef.h>
+ #include <linux/err.h>
+ #include <linux/percpu.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+@@ -129,7 +132,35 @@ static void ecache_work(struct work_stru
+ 	if (delay >= 0)
+ 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
+ }
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
++				  u32 portid, int report)
++{
++	struct nf_conntrack_ecache *e;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return 0;
++
++	if (nf_ct_is_confirmed(ct)) {
++		struct nf_ct_event item = {
++			.ct = ct,
++			.portid	= e->portid ? e->portid : portid,
++			.report = report
++		};
++		/* This is a resent of a destroy event? If so, skip missed */
++		unsigned long missed = e->portid ? 0 : e->missed;
++
++		if (!((eventmask | missed) & e->ctmask))
++			return 0;
+ 
++		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
++	}
++
++	return 0;
++}
++#else
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+ 				  u32 portid, int report)
+ {
+@@ -184,10 +215,52 @@ out_unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
+ 
+ /* deliver cached events and clear cache entry - must be called with locally
+  * disabled softirqs */
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++void nf_ct_deliver_cached_events(struct nf_conn *ct)
++{
++	unsigned long events, missed;
++	struct nf_conntrack_ecache *e;
++	struct nf_ct_event item;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return;
++
++	events = xchg(&e->cache, 0);
++
++	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
++		return;
++
++	/* We make a copy of the missed event cache without taking
++	 * the lock, thus we may send missed events twice. However,
++	 * this does not harm and it happens very rarely. */
++	missed = e->missed;
++
++	if (!((events | missed) & e->ctmask))
++		return;
++
++	item.ct = ct;
++	item.portid = 0;
++	item.report = 0;
++
++	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++			events | missed,
++			&item);
++
++	if (likely(!missed))
++		return;
++
++	spin_lock_bh(&ct->lock);
++		e->missed &= ~missed;
++	spin_unlock_bh(&ct->lock);
++}
++#else
+ void nf_ct_deliver_cached_events(struct nf_conn *ct)
+ {
+ 	struct net *net = nf_ct_net(ct);
+@@ -238,6 +311,7 @@ void nf_ct_deliver_cached_events(struct
+ out_unlock:
+ 	rcu_read_unlock();
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
+ 
+ void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
+@@ -270,6 +344,13 @@ out_unlock:
+ 	rcu_read_unlock();
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_register_notifier(struct net *net,
++				   struct notifier_block *nb)
++{
++        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ int nf_conntrack_register_notifier(struct net *net,
+ 				   struct nf_ct_event_notifier *new)
+ {
+@@ -290,8 +371,15 @@ out_unlock:
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *new)
+ {
+@@ -305,6 +393,7 @@ void nf_conntrack_unregister_notifier(st
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	/* synchronize_rcu() is called from ctnetlink_exit. */
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
+ 
+ int nf_ct_expect_register_notifier(struct net *net,
+--- a/net/netfilter/nf_conntrack_netlink.c
++++ b/net/netfilter/nf_conntrack_netlink.c
+@@ -703,13 +703,20 @@ static size_t ctnetlink_nlmsg_size(const
+ }
+ 
+ static int
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++ctnetlink_conntrack_event(struct notifier_block *this, unsigned long events, void *ptr)
++#else
+ ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
++#endif
+ {
+ 	const struct nf_conntrack_zone *zone;
+ 	struct net *net;
+ 	struct nlmsghdr *nlh;
+ 	struct nfgenmsg *nfmsg;
+ 	struct nlattr *nest_parms;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
++#endif
+ 	struct nf_conn *ct = item->ct;
+ 	struct sk_buff *skb;
+ 	unsigned int type;
+@@ -3783,9 +3790,15 @@ static int ctnetlink_stat_exp_cpu(struct
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++static struct notifier_block ctnl_notifier = {
++	.notifier_call = ctnetlink_conntrack_event,
++};
++#else
+ static struct nf_ct_event_notifier ctnl_notifier = {
+ 	.fcn = ctnetlink_conntrack_event,
+ };
++#endif
+ 
+ static struct nf_exp_event_notifier ctnl_notifier_exp = {
+ 	.fcn = ctnetlink_expect_event,
diff --git a/target/linux/rockchip/Makefile b/target/linux/rockchip/Makefile
index 7aeb0a3d55..f7b6995911 100644
--- a/target/linux/rockchip/Makefile
+++ b/target/linux/rockchip/Makefile
@@ -4,7 +4,7 @@ include $(TOPDIR)/rules.mk
 
 BOARD:=rockchip
 BOARDNAME:=Rockchip
-FEATURES:=ext4 audio usb usbgadget display gpio fpu rootfs-part boot-part squashfs
+FEATURES:=ext4 audio usb usbgadget display gpio fpu pci pcie rootfs-part boot-part squashfs
 SUBTARGETS:=armv8
 
 KERNEL_PATCHVER=5.4
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds b/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
index e97ea3312d..bfecd0874c 100644
--- a/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/01_leds
@@ -8,7 +8,8 @@ boardname="${board##*,}"
 board_config_update
 
 case $board in
-friendlyarm,nanopi-r2s)
+friendlyarm,nanopi-r2s|\
+friendlyarm,nanopi-r4s)
 	ucidef_set_led_netdev "wan" "WAN" "$boardname:green:wan" "eth0"
 	ucidef_set_led_netdev "lan" "LAN" "$boardname:green:lan" "eth1"
 	;;
diff --git a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
index 99f55513aa..0c22601c95 100644
--- a/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
+++ b/target/linux/rockchip/armv8/base-files/etc/board.d/02_network
@@ -7,7 +7,8 @@ rockchip_setup_interfaces()
 	local board="$1"
 
 	case "$board" in
-	friendlyarm,nanopi-r2s)
+	friendlyarm,nanopi-r2s|\
+	friendlyarm,nanopi-r4s)
 		ucidef_set_interfaces_lan_wan 'eth1' 'eth0'
 		;;
 	*)
@@ -35,6 +36,10 @@ rockchip_setup_macs()
 		wan_mac=$(nanopi_r2s_generate_mac)
 		lan_mac=$(macaddr_add "$wan_mac" +1)
 		;;
+	friendlyarm,nanopi-r4s)
+		wan_mac=$(cat /sys/class/net/eth0/address)
+		lan_mac=$(macaddr_add "$wan_mac" +1)
+		;;
 	esac
 
 	[ -n "$lan_mac" ] && ucidef_set_interface_macaddr "lan" $lan_mac
diff --git a/target/linux/rockchip/armv8/base-files/etc/hotplug.d/net/40-net-smp-affinity b/target/linux/rockchip/armv8/base-files/etc/hotplug.d/net/40-net-smp-affinity
index 44716258bf..9e4a4cf4fc 100644
--- a/target/linux/rockchip/armv8/base-files/etc/hotplug.d/net/40-net-smp-affinity
+++ b/target/linux/rockchip/armv8/base-files/etc/hotplug.d/net/40-net-smp-affinity
@@ -26,5 +26,9 @@ friendlyarm,nanopi-r2s)
 	set_interface_core 2 "eth0"
 	set_interface_core 4 "eth1" "xhci-hcd:usb3"
 	;;
+friendlyarm,nanopi-r4s)
+	set_interface_core 10 "eth0"
+	set_interface_core 20 "eth1"
+	;;
 esac
 
diff --git a/target/linux/rockchip/armv8/config-5.10 b/target/linux/rockchip/armv8/config-5.10
index eaef238c92..b5062cbd32 100644
--- a/target/linux/rockchip/armv8/config-5.10
+++ b/target/linux/rockchip/armv8/config-5.10
@@ -61,6 +61,7 @@ CONFIG_ARM_MHU=y
 CONFIG_ARM_PSCI_CPUIDLE=y
 CONFIG_ARM_PSCI_CPUIDLE_DOMAIN=y
 CONFIG_ARM_PSCI_FW=y
+CONFIG_ARM_RK3328_DMC_DEVFREQ=y
 # CONFIG_ARM_RK3399_DMC_DEVFREQ is not set
 # CONFIG_ARM_SCMI_PROTOCOL is not set
 CONFIG_ARM_SCPI_CPUFREQ=y
@@ -162,6 +163,10 @@ CONFIG_CRYPTO_AEAD2=y
 CONFIG_CRYPTO_CRC32=y
 CONFIG_CRYPTO_CRC32C=y
 CONFIG_CRYPTO_CRCT10DIF=y
+# CONFIG_CRYPTO_DEV_ROCKCHIP is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+CONFIG_CRYPTO_DRBG_MENU=y
 CONFIG_CRYPTO_HASH=y
 CONFIG_CRYPTO_HASH2=y
 CONFIG_CRYPTO_MANAGER=y
diff --git a/target/linux/rockchip/armv8/config-5.4 b/target/linux/rockchip/armv8/config-5.4
index f6ec79b121..96291fab91 100644
--- a/target/linux/rockchip/armv8/config-5.4
+++ b/target/linux/rockchip/armv8/config-5.4
@@ -63,6 +63,7 @@ CONFIG_ARM_GIC_V3_ITS_PCI=y
 CONFIG_ARM_MHU=y
 CONFIG_ARM_PSCI_CPUIDLE=y
 CONFIG_ARM_PSCI_FW=y
+CONFIG_ARM_RK3328_DMC_DEVFREQ=y
 # CONFIG_ARM_RK3399_DMC_DEVFREQ is not set
 # CONFIG_ARM_SCMI_PROTOCOL is not set
 CONFIG_ARM_SCPI_CPUFREQ=y
diff --git a/target/linux/rockchip/files/arch/arm64/boot/dts/rockchip/rk3328-dram-nanopi2-timing.dtsi b/target/linux/rockchip/files/arch/arm64/boot/dts/rockchip/rk3328-dram-nanopi2-timing.dtsi
new file mode 100644
index 0000000000..a3f5ff4bdc
--- /dev/null
+++ b/target/linux/rockchip/files/arch/arm64/boot/dts/rockchip/rk3328-dram-nanopi2-timing.dtsi
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <dt-bindings/clock/rockchip-ddr.h>
+#include <dt-bindings/memory/rk3328-dram.h>
+
+/ {
+	ddr_timing: ddr_timing {
+		compatible = "rockchip,ddr-timing";
+		ddr3_speed_bin = <DDR3_DEFAULT>;
+		ddr4_speed_bin = <DDR4_DEFAULT>;
+		pd_idle = <0>;
+		sr_idle = <0>;
+		sr_mc_gate_idle = <0>;
+		srpd_lite_idle	= <0>;
+		standby_idle = <0>;
+
+		auto_pd_dis_freq = <1066>;
+		auto_sr_dis_freq = <800>;
+		ddr3_dll_dis_freq = <300>;
+		ddr4_dll_dis_freq = <625>;
+		phy_dll_dis_freq = <400>;
+
+		ddr3_odt_dis_freq = <100>;
+		phy_ddr3_odt_dis_freq = <100>;
+		ddr3_drv = <DDR3_DS_40ohm>;
+		ddr3_odt = <DDR3_ODT_120ohm>;
+		phy_ddr3_ca_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_ck_drv = <PHY_DDR3_RON_RTT_45ohm>;
+		phy_ddr3_dq_drv = <PHY_DDR3_RON_RTT_34ohm>;
+		phy_ddr3_odt = <PHY_DDR3_RON_RTT_225ohm>;
+
+		lpddr3_odt_dis_freq = <666>;
+		phy_lpddr3_odt_dis_freq = <666>;
+		lpddr3_drv = <LP3_DS_40ohm>;
+		lpddr3_odt = <LP3_ODT_240ohm>;
+		phy_lpddr3_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_lpddr3_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_lpddr3_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		lpddr4_odt_dis_freq = <800>;
+		phy_lpddr4_odt_dis_freq = <800>;
+		lpddr4_drv = <LP4_PDDS_60ohm>;
+		lpddr4_dq_odt = <LP4_DQ_ODT_40ohm>;
+		lpddr4_ca_odt = <LP4_CA_ODT_40ohm>;
+		phy_lpddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_40ohm>;
+		phy_lpddr4_ck_cs_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_80ohm>;
+		phy_lpddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_60ohm>;
+
+		ddr4_odt_dis_freq = <666>;
+		phy_ddr4_odt_dis_freq = <666>;
+		ddr4_drv = <DDR4_DS_34ohm>;
+		ddr4_odt = <DDR4_RTT_NOM_240ohm>;
+		phy_ddr4_ca_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_ck_drv = <PHY_DDR4_LPDDR3_RON_RTT_43ohm>;
+		phy_ddr4_dq_drv = <PHY_DDR4_LPDDR3_RON_RTT_34ohm>;
+		phy_ddr4_odt = <PHY_DDR4_LPDDR3_RON_RTT_240ohm>;
+
+		/* CA de-skew, one step is 47.8ps, range 0-15 */
+		ddr3a1_ddr4a9_de-skew = <7>;
+		ddr3a0_ddr4a10_de-skew = <7>;
+		ddr3a3_ddr4a6_de-skew = <8>;
+		ddr3a2_ddr4a4_de-skew = <8>;
+		ddr3a5_ddr4a8_de-skew = <7>;
+		ddr3a4_ddr4a5_de-skew = <9>;
+		ddr3a7_ddr4a11_de-skew = <7>;
+		ddr3a6_ddr4a7_de-skew = <9>;
+		ddr3a9_ddr4a0_de-skew = <8>;
+		ddr3a8_ddr4a13_de-skew = <7>;
+		ddr3a11_ddr4a3_de-skew = <9>;
+		ddr3a10_ddr4cs0_de-skew = <7>;
+		ddr3a13_ddr4a2_de-skew = <8>;
+		ddr3a12_ddr4ba1_de-skew = <7>;
+		ddr3a15_ddr4odt0_de-skew = <7>;
+		ddr3a14_ddr4a1_de-skew = <8>;
+		ddr3ba1_ddr4a15_de-skew = <7>;
+		ddr3ba0_ddr4bg0_de-skew = <7>;
+		ddr3ras_ddr4cke_de-skew = <7>;
+		ddr3ba2_ddr4ba0_de-skew = <8>;
+		ddr3we_ddr4bg1_de-skew = <8>;
+		ddr3cas_ddr4a12_de-skew = <7>;
+		ddr3ckn_ddr4ckn_de-skew = <8>;
+		ddr3ckp_ddr4ckp_de-skew = <8>;
+		ddr3cke_ddr4a16_de-skew = <8>;
+		ddr3odt0_ddr4a14_de-skew = <7>;
+		ddr3cs0_ddr4act_de-skew = <8>;
+		ddr3reset_ddr4reset_de-skew = <7>;
+		ddr3cs1_ddr4cs1_de-skew = <7>;
+		ddr3odt1_ddr4odt1_de-skew = <7>;
+
+		/* DATA de-skew
+		 * RX one step is 25.1ps, range 0-15
+		 * TX one step is 47.8ps, range 0-15
+		 */
+		cs0_dm0_rx_de-skew = <7>;
+		cs0_dm0_tx_de-skew = <8>;
+		cs0_dq0_rx_de-skew = <7>;
+		cs0_dq0_tx_de-skew = <8>;
+		cs0_dq1_rx_de-skew = <7>;
+		cs0_dq1_tx_de-skew = <8>;
+		cs0_dq2_rx_de-skew = <7>;
+		cs0_dq2_tx_de-skew = <8>;
+		cs0_dq3_rx_de-skew = <7>;
+		cs0_dq3_tx_de-skew = <8>;
+		cs0_dq4_rx_de-skew = <7>;
+		cs0_dq4_tx_de-skew = <8>;
+		cs0_dq5_rx_de-skew = <7>;
+		cs0_dq5_tx_de-skew = <8>;
+		cs0_dq6_rx_de-skew = <7>;
+		cs0_dq6_tx_de-skew = <8>;
+		cs0_dq7_rx_de-skew = <7>;
+		cs0_dq7_tx_de-skew = <8>;
+		cs0_dqs0_rx_de-skew = <6>;
+		cs0_dqs0p_tx_de-skew = <9>;
+		cs0_dqs0n_tx_de-skew = <9>;
+
+		cs0_dm1_rx_de-skew = <7>;
+		cs0_dm1_tx_de-skew = <7>;
+		cs0_dq8_rx_de-skew = <7>;
+		cs0_dq8_tx_de-skew = <8>;
+		cs0_dq9_rx_de-skew = <7>;
+		cs0_dq9_tx_de-skew = <7>;
+		cs0_dq10_rx_de-skew = <7>;
+		cs0_dq10_tx_de-skew = <8>;
+		cs0_dq11_rx_de-skew = <7>;
+		cs0_dq11_tx_de-skew = <7>;
+		cs0_dq12_rx_de-skew = <7>;
+		cs0_dq12_tx_de-skew = <8>;
+		cs0_dq13_rx_de-skew = <7>;
+		cs0_dq13_tx_de-skew = <7>;
+		cs0_dq14_rx_de-skew = <7>;
+		cs0_dq14_tx_de-skew = <8>;
+		cs0_dq15_rx_de-skew = <7>;
+		cs0_dq15_tx_de-skew = <7>;
+		cs0_dqs1_rx_de-skew = <7>;
+		cs0_dqs1p_tx_de-skew = <9>;
+		cs0_dqs1n_tx_de-skew = <9>;
+
+		cs0_dm2_rx_de-skew = <7>;
+		cs0_dm2_tx_de-skew = <8>;
+		cs0_dq16_rx_de-skew = <7>;
+		cs0_dq16_tx_de-skew = <8>;
+		cs0_dq17_rx_de-skew = <7>;
+		cs0_dq17_tx_de-skew = <8>;
+		cs0_dq18_rx_de-skew = <7>;
+		cs0_dq18_tx_de-skew = <8>;
+		cs0_dq19_rx_de-skew = <7>;
+		cs0_dq19_tx_de-skew = <8>;
+		cs0_dq20_rx_de-skew = <7>;
+		cs0_dq20_tx_de-skew = <8>;
+		cs0_dq21_rx_de-skew = <7>;
+		cs0_dq21_tx_de-skew = <8>;
+		cs0_dq22_rx_de-skew = <7>;
+		cs0_dq22_tx_de-skew = <8>;
+		cs0_dq23_rx_de-skew = <7>;
+		cs0_dq23_tx_de-skew = <8>;
+		cs0_dqs2_rx_de-skew = <6>;
+		cs0_dqs2p_tx_de-skew = <9>;
+		cs0_dqs2n_tx_de-skew = <9>;
+
+		cs0_dm3_rx_de-skew = <7>;
+		cs0_dm3_tx_de-skew = <7>;
+		cs0_dq24_rx_de-skew = <7>;
+		cs0_dq24_tx_de-skew = <8>;
+		cs0_dq25_rx_de-skew = <7>;
+		cs0_dq25_tx_de-skew = <7>;
+		cs0_dq26_rx_de-skew = <7>;
+		cs0_dq26_tx_de-skew = <7>;
+		cs0_dq27_rx_de-skew = <7>;
+		cs0_dq27_tx_de-skew = <7>;
+		cs0_dq28_rx_de-skew = <7>;
+		cs0_dq28_tx_de-skew = <7>;
+		cs0_dq29_rx_de-skew = <7>;
+		cs0_dq29_tx_de-skew = <7>;
+		cs0_dq30_rx_de-skew = <7>;
+		cs0_dq30_tx_de-skew = <7>;
+		cs0_dq31_rx_de-skew = <7>;
+		cs0_dq31_tx_de-skew = <7>;
+		cs0_dqs3_rx_de-skew = <7>;
+		cs0_dqs3p_tx_de-skew = <9>;
+		cs0_dqs3n_tx_de-skew = <9>;
+
+		cs1_dm0_rx_de-skew = <7>;
+		cs1_dm0_tx_de-skew = <8>;
+		cs1_dq0_rx_de-skew = <7>;
+		cs1_dq0_tx_de-skew = <8>;
+		cs1_dq1_rx_de-skew = <7>;
+		cs1_dq1_tx_de-skew = <8>;
+		cs1_dq2_rx_de-skew = <7>;
+		cs1_dq2_tx_de-skew = <8>;
+		cs1_dq3_rx_de-skew = <7>;
+		cs1_dq3_tx_de-skew = <8>;
+		cs1_dq4_rx_de-skew = <7>;
+		cs1_dq4_tx_de-skew = <8>;
+		cs1_dq5_rx_de-skew = <7>;
+		cs1_dq5_tx_de-skew = <8>;
+		cs1_dq6_rx_de-skew = <7>;
+		cs1_dq6_tx_de-skew = <8>;
+		cs1_dq7_rx_de-skew = <7>;
+		cs1_dq7_tx_de-skew = <8>;
+		cs1_dqs0_rx_de-skew = <6>;
+		cs1_dqs0p_tx_de-skew = <9>;
+		cs1_dqs0n_tx_de-skew = <9>;
+
+		cs1_dm1_rx_de-skew = <7>;
+		cs1_dm1_tx_de-skew = <7>;
+		cs1_dq8_rx_de-skew = <7>;
+		cs1_dq8_tx_de-skew = <8>;
+		cs1_dq9_rx_de-skew = <7>;
+		cs1_dq9_tx_de-skew = <7>;
+		cs1_dq10_rx_de-skew = <7>;
+		cs1_dq10_tx_de-skew = <8>;
+		cs1_dq11_rx_de-skew = <7>;
+		cs1_dq11_tx_de-skew = <7>;
+		cs1_dq12_rx_de-skew = <7>;
+		cs1_dq12_tx_de-skew = <8>;
+		cs1_dq13_rx_de-skew = <7>;
+		cs1_dq13_tx_de-skew = <7>;
+		cs1_dq14_rx_de-skew = <7>;
+		cs1_dq14_tx_de-skew = <8>;
+		cs1_dq15_rx_de-skew = <7>;
+		cs1_dq15_tx_de-skew = <7>;
+		cs1_dqs1_rx_de-skew = <7>;
+		cs1_dqs1p_tx_de-skew = <9>;
+		cs1_dqs1n_tx_de-skew = <9>;
+
+		cs1_dm2_rx_de-skew = <7>;
+		cs1_dm2_tx_de-skew = <8>;
+		cs1_dq16_rx_de-skew = <7>;
+		cs1_dq16_tx_de-skew = <8>;
+		cs1_dq17_rx_de-skew = <7>;
+		cs1_dq17_tx_de-skew = <8>;
+		cs1_dq18_rx_de-skew = <7>;
+		cs1_dq18_tx_de-skew = <8>;
+		cs1_dq19_rx_de-skew = <7>;
+		cs1_dq19_tx_de-skew = <8>;
+		cs1_dq20_rx_de-skew = <7>;
+		cs1_dq20_tx_de-skew = <8>;
+		cs1_dq21_rx_de-skew = <7>;
+		cs1_dq21_tx_de-skew = <8>;
+		cs1_dq22_rx_de-skew = <7>;
+		cs1_dq22_tx_de-skew = <8>;
+		cs1_dq23_rx_de-skew = <7>;
+		cs1_dq23_tx_de-skew = <8>;
+		cs1_dqs2_rx_de-skew = <6>;
+		cs1_dqs2p_tx_de-skew = <9>;
+		cs1_dqs2n_tx_de-skew = <9>;
+
+		cs1_dm3_rx_de-skew = <7>;
+		cs1_dm3_tx_de-skew = <7>;
+		cs1_dq24_rx_de-skew = <7>;
+		cs1_dq24_tx_de-skew = <8>;
+		cs1_dq25_rx_de-skew = <7>;
+		cs1_dq25_tx_de-skew = <7>;
+		cs1_dq26_rx_de-skew = <7>;
+		cs1_dq26_tx_de-skew = <7>;
+		cs1_dq27_rx_de-skew = <7>;
+		cs1_dq27_tx_de-skew = <7>;
+		cs1_dq28_rx_de-skew = <7>;
+		cs1_dq28_tx_de-skew = <7>;
+		cs1_dq29_rx_de-skew = <7>;
+		cs1_dq29_tx_de-skew = <7>;
+		cs1_dq30_rx_de-skew = <7>;
+		cs1_dq30_tx_de-skew = <7>;
+		cs1_dq31_rx_de-skew = <7>;
+		cs1_dq31_tx_de-skew = <7>;
+		cs1_dqs3_rx_de-skew = <7>;
+		cs1_dqs3p_tx_de-skew = <9>;
+		cs1_dqs3n_tx_de-skew = <9>;
+	};
+};
diff --git a/target/linux/rockchip/files/drivers/devfreq/rk3328_dmc.c b/target/linux/rockchip/files/drivers/devfreq/rk3328_dmc.c
new file mode 100644
index 0000000000..72601a0904
--- /dev/null
+++ b/target/linux/rockchip/files/drivers/devfreq/rk3328_dmc.c
@@ -0,0 +1,852 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd.
+ * Author: Lin Huang <hl@rock-chips.com>
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/devfreq.h>
+#include <linux/devfreq-event.h>
+#include <linux/interrupt.h>
+#include <linux/iversion.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/rwsem.h>
+#include <linux/suspend.h>
+#include <linux/version.h>
+
+#include <soc/rockchip/rockchip_sip.h>
+
+#define DTS_PAR_OFFSET		(4096)
+
+struct share_params {
+	u32 hz;
+	u32 lcdc_type;
+	u32 vop;
+	u32 vop_dclk_mode;
+	u32 sr_idle_en;
+	u32 addr_mcu_el3;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag1;
+	/*
+	 * 1: need to wait flag1
+	 * 0: never wait flag1
+	 */
+	u32 wait_flag0;
+	u32 complt_hwirq;
+	/* if need, add parameter after */
+};
+
+static struct share_params *ddr_psci_param;
+
+/* hope this define can adapt all future platform */
+static const char * const rk3328_dts_timing[] = {
+	"ddr3_speed_bin",
+	"ddr4_speed_bin",
+	"pd_idle",
+	"sr_idle",
+	"sr_mc_gate_idle",
+	"srpd_lite_idle",
+	"standby_idle",
+
+	"auto_pd_dis_freq",
+	"auto_sr_dis_freq",
+	"ddr3_dll_dis_freq",
+	"ddr4_dll_dis_freq",
+	"phy_dll_dis_freq",
+
+	"ddr3_odt_dis_freq",
+	"phy_ddr3_odt_dis_freq",
+	"ddr3_drv",
+	"ddr3_odt",
+	"phy_ddr3_ca_drv",
+	"phy_ddr3_ck_drv",
+	"phy_ddr3_dq_drv",
+	"phy_ddr3_odt",
+
+	"lpddr3_odt_dis_freq",
+	"phy_lpddr3_odt_dis_freq",
+	"lpddr3_drv",
+	"lpddr3_odt",
+	"phy_lpddr3_ca_drv",
+	"phy_lpddr3_ck_drv",
+	"phy_lpddr3_dq_drv",
+	"phy_lpddr3_odt",
+
+	"lpddr4_odt_dis_freq",
+	"phy_lpddr4_odt_dis_freq",
+	"lpddr4_drv",
+	"lpddr4_dq_odt",
+	"lpddr4_ca_odt",
+	"phy_lpddr4_ca_drv",
+	"phy_lpddr4_ck_cs_drv",
+	"phy_lpddr4_dq_drv",
+	"phy_lpddr4_odt",
+
+	"ddr4_odt_dis_freq",
+	"phy_ddr4_odt_dis_freq",
+	"ddr4_drv",
+	"ddr4_odt",
+	"phy_ddr4_ca_drv",
+	"phy_ddr4_ck_drv",
+	"phy_ddr4_dq_drv",
+	"phy_ddr4_odt",
+};
+
+static const char * const rk3328_dts_ca_timing[] = {
+	"ddr3a1_ddr4a9_de-skew",
+	"ddr3a0_ddr4a10_de-skew",
+	"ddr3a3_ddr4a6_de-skew",
+	"ddr3a2_ddr4a4_de-skew",
+	"ddr3a5_ddr4a8_de-skew",
+	"ddr3a4_ddr4a5_de-skew",
+	"ddr3a7_ddr4a11_de-skew",
+	"ddr3a6_ddr4a7_de-skew",
+	"ddr3a9_ddr4a0_de-skew",
+	"ddr3a8_ddr4a13_de-skew",
+	"ddr3a11_ddr4a3_de-skew",
+	"ddr3a10_ddr4cs0_de-skew",
+	"ddr3a13_ddr4a2_de-skew",
+	"ddr3a12_ddr4ba1_de-skew",
+	"ddr3a15_ddr4odt0_de-skew",
+	"ddr3a14_ddr4a1_de-skew",
+	"ddr3ba1_ddr4a15_de-skew",
+	"ddr3ba0_ddr4bg0_de-skew",
+	"ddr3ras_ddr4cke_de-skew",
+	"ddr3ba2_ddr4ba0_de-skew",
+	"ddr3we_ddr4bg1_de-skew",
+	"ddr3cas_ddr4a12_de-skew",
+	"ddr3ckn_ddr4ckn_de-skew",
+	"ddr3ckp_ddr4ckp_de-skew",
+	"ddr3cke_ddr4a16_de-skew",
+	"ddr3odt0_ddr4a14_de-skew",
+	"ddr3cs0_ddr4act_de-skew",
+	"ddr3reset_ddr4reset_de-skew",
+	"ddr3cs1_ddr4cs1_de-skew",
+	"ddr3odt1_ddr4odt1_de-skew",
+};
+
+static const char * const rk3328_dts_cs0_timing[] = {
+	"cs0_dm0_rx_de-skew",
+	"cs0_dm0_tx_de-skew",
+	"cs0_dq0_rx_de-skew",
+	"cs0_dq0_tx_de-skew",
+	"cs0_dq1_rx_de-skew",
+	"cs0_dq1_tx_de-skew",
+	"cs0_dq2_rx_de-skew",
+	"cs0_dq2_tx_de-skew",
+	"cs0_dq3_rx_de-skew",
+	"cs0_dq3_tx_de-skew",
+	"cs0_dq4_rx_de-skew",
+	"cs0_dq4_tx_de-skew",
+	"cs0_dq5_rx_de-skew",
+	"cs0_dq5_tx_de-skew",
+	"cs0_dq6_rx_de-skew",
+	"cs0_dq6_tx_de-skew",
+	"cs0_dq7_rx_de-skew",
+	"cs0_dq7_tx_de-skew",
+	"cs0_dqs0_rx_de-skew",
+	"cs0_dqs0p_tx_de-skew",
+	"cs0_dqs0n_tx_de-skew",
+
+	"cs0_dm1_rx_de-skew",
+	"cs0_dm1_tx_de-skew",
+	"cs0_dq8_rx_de-skew",
+	"cs0_dq8_tx_de-skew",
+	"cs0_dq9_rx_de-skew",
+	"cs0_dq9_tx_de-skew",
+	"cs0_dq10_rx_de-skew",
+	"cs0_dq10_tx_de-skew",
+	"cs0_dq11_rx_de-skew",
+	"cs0_dq11_tx_de-skew",
+	"cs0_dq12_rx_de-skew",
+	"cs0_dq12_tx_de-skew",
+	"cs0_dq13_rx_de-skew",
+	"cs0_dq13_tx_de-skew",
+	"cs0_dq14_rx_de-skew",
+	"cs0_dq14_tx_de-skew",
+	"cs0_dq15_rx_de-skew",
+	"cs0_dq15_tx_de-skew",
+	"cs0_dqs1_rx_de-skew",
+	"cs0_dqs1p_tx_de-skew",
+	"cs0_dqs1n_tx_de-skew",
+
+	"cs0_dm2_rx_de-skew",
+	"cs0_dm2_tx_de-skew",
+	"cs0_dq16_rx_de-skew",
+	"cs0_dq16_tx_de-skew",
+	"cs0_dq17_rx_de-skew",
+	"cs0_dq17_tx_de-skew",
+	"cs0_dq18_rx_de-skew",
+	"cs0_dq18_tx_de-skew",
+	"cs0_dq19_rx_de-skew",
+	"cs0_dq19_tx_de-skew",
+	"cs0_dq20_rx_de-skew",
+	"cs0_dq20_tx_de-skew",
+	"cs0_dq21_rx_de-skew",
+	"cs0_dq21_tx_de-skew",
+	"cs0_dq22_rx_de-skew",
+	"cs0_dq22_tx_de-skew",
+	"cs0_dq23_rx_de-skew",
+	"cs0_dq23_tx_de-skew",
+	"cs0_dqs2_rx_de-skew",
+	"cs0_dqs2p_tx_de-skew",
+	"cs0_dqs2n_tx_de-skew",
+
+	"cs0_dm3_rx_de-skew",
+	"cs0_dm3_tx_de-skew",
+	"cs0_dq24_rx_de-skew",
+	"cs0_dq24_tx_de-skew",
+	"cs0_dq25_rx_de-skew",
+	"cs0_dq25_tx_de-skew",
+	"cs0_dq26_rx_de-skew",
+	"cs0_dq26_tx_de-skew",
+	"cs0_dq27_rx_de-skew",
+	"cs0_dq27_tx_de-skew",
+	"cs0_dq28_rx_de-skew",
+	"cs0_dq28_tx_de-skew",
+	"cs0_dq29_rx_de-skew",
+	"cs0_dq29_tx_de-skew",
+	"cs0_dq30_rx_de-skew",
+	"cs0_dq30_tx_de-skew",
+	"cs0_dq31_rx_de-skew",
+	"cs0_dq31_tx_de-skew",
+	"cs0_dqs3_rx_de-skew",
+	"cs0_dqs3p_tx_de-skew",
+	"cs0_dqs3n_tx_de-skew",
+};
+
+static const char * const rk3328_dts_cs1_timing[] = {
+	"cs1_dm0_rx_de-skew",
+	"cs1_dm0_tx_de-skew",
+	"cs1_dq0_rx_de-skew",
+	"cs1_dq0_tx_de-skew",
+	"cs1_dq1_rx_de-skew",
+	"cs1_dq1_tx_de-skew",
+	"cs1_dq2_rx_de-skew",
+	"cs1_dq2_tx_de-skew",
+	"cs1_dq3_rx_de-skew",
+	"cs1_dq3_tx_de-skew",
+	"cs1_dq4_rx_de-skew",
+	"cs1_dq4_tx_de-skew",
+	"cs1_dq5_rx_de-skew",
+	"cs1_dq5_tx_de-skew",
+	"cs1_dq6_rx_de-skew",
+	"cs1_dq6_tx_de-skew",
+	"cs1_dq7_rx_de-skew",
+	"cs1_dq7_tx_de-skew",
+	"cs1_dqs0_rx_de-skew",
+	"cs1_dqs0p_tx_de-skew",
+	"cs1_dqs0n_tx_de-skew",
+
+	"cs1_dm1_rx_de-skew",
+	"cs1_dm1_tx_de-skew",
+	"cs1_dq8_rx_de-skew",
+	"cs1_dq8_tx_de-skew",
+	"cs1_dq9_rx_de-skew",
+	"cs1_dq9_tx_de-skew",
+	"cs1_dq10_rx_de-skew",
+	"cs1_dq10_tx_de-skew",
+	"cs1_dq11_rx_de-skew",
+	"cs1_dq11_tx_de-skew",
+	"cs1_dq12_rx_de-skew",
+	"cs1_dq12_tx_de-skew",
+	"cs1_dq13_rx_de-skew",
+	"cs1_dq13_tx_de-skew",
+	"cs1_dq14_rx_de-skew",
+	"cs1_dq14_tx_de-skew",
+	"cs1_dq15_rx_de-skew",
+	"cs1_dq15_tx_de-skew",
+	"cs1_dqs1_rx_de-skew",
+	"cs1_dqs1p_tx_de-skew",
+	"cs1_dqs1n_tx_de-skew",
+
+	"cs1_dm2_rx_de-skew",
+	"cs1_dm2_tx_de-skew",
+	"cs1_dq16_rx_de-skew",
+	"cs1_dq16_tx_de-skew",
+	"cs1_dq17_rx_de-skew",
+	"cs1_dq17_tx_de-skew",
+	"cs1_dq18_rx_de-skew",
+	"cs1_dq18_tx_de-skew",
+	"cs1_dq19_rx_de-skew",
+	"cs1_dq19_tx_de-skew",
+	"cs1_dq20_rx_de-skew",
+	"cs1_dq20_tx_de-skew",
+	"cs1_dq21_rx_de-skew",
+	"cs1_dq21_tx_de-skew",
+	"cs1_dq22_rx_de-skew",
+	"cs1_dq22_tx_de-skew",
+	"cs1_dq23_rx_de-skew",
+	"cs1_dq23_tx_de-skew",
+	"cs1_dqs2_rx_de-skew",
+	"cs1_dqs2p_tx_de-skew",
+	"cs1_dqs2n_tx_de-skew",
+
+	"cs1_dm3_rx_de-skew",
+	"cs1_dm3_tx_de-skew",
+	"cs1_dq24_rx_de-skew",
+	"cs1_dq24_tx_de-skew",
+	"cs1_dq25_rx_de-skew",
+	"cs1_dq25_tx_de-skew",
+	"cs1_dq26_rx_de-skew",
+	"cs1_dq26_tx_de-skew",
+	"cs1_dq27_rx_de-skew",
+	"cs1_dq27_tx_de-skew",
+	"cs1_dq28_rx_de-skew",
+	"cs1_dq28_tx_de-skew",
+	"cs1_dq29_rx_de-skew",
+	"cs1_dq29_tx_de-skew",
+	"cs1_dq30_rx_de-skew",
+	"cs1_dq30_tx_de-skew",
+	"cs1_dq31_rx_de-skew",
+	"cs1_dq31_tx_de-skew",
+	"cs1_dqs3_rx_de-skew",
+	"cs1_dqs3p_tx_de-skew",
+	"cs1_dqs3n_tx_de-skew",
+};
+
+struct rk3328_ddr_dts_config_timing {
+	unsigned int ddr3_speed_bin;
+	unsigned int ddr4_speed_bin;
+	unsigned int pd_idle;
+	unsigned int sr_idle;
+	unsigned int sr_mc_gate_idle;
+	unsigned int srpd_lite_idle;
+	unsigned int standby_idle;
+
+	unsigned int auto_pd_dis_freq;
+	unsigned int auto_sr_dis_freq;
+	/* for ddr3 only */
+	unsigned int ddr3_dll_dis_freq;
+	/* for ddr4 only */
+	unsigned int ddr4_dll_dis_freq;
+	unsigned int phy_dll_dis_freq;
+
+	unsigned int ddr3_odt_dis_freq;
+	unsigned int phy_ddr3_odt_dis_freq;
+	unsigned int ddr3_drv;
+	unsigned int ddr3_odt;
+	unsigned int phy_ddr3_ca_drv;
+	unsigned int phy_ddr3_ck_drv;
+	unsigned int phy_ddr3_dq_drv;
+	unsigned int phy_ddr3_odt;
+
+	unsigned int lpddr3_odt_dis_freq;
+	unsigned int phy_lpddr3_odt_dis_freq;
+	unsigned int lpddr3_drv;
+	unsigned int lpddr3_odt;
+	unsigned int phy_lpddr3_ca_drv;
+	unsigned int phy_lpddr3_ck_drv;
+	unsigned int phy_lpddr3_dq_drv;
+	unsigned int phy_lpddr3_odt;
+
+	unsigned int lpddr4_odt_dis_freq;
+	unsigned int phy_lpddr4_odt_dis_freq;
+	unsigned int lpddr4_drv;
+	unsigned int lpddr4_dq_odt;
+	unsigned int lpddr4_ca_odt;
+	unsigned int phy_lpddr4_ca_drv;
+	unsigned int phy_lpddr4_ck_cs_drv;
+	unsigned int phy_lpddr4_dq_drv;
+	unsigned int phy_lpddr4_odt;
+
+	unsigned int ddr4_odt_dis_freq;
+	unsigned int phy_ddr4_odt_dis_freq;
+	unsigned int ddr4_drv;
+	unsigned int ddr4_odt;
+	unsigned int phy_ddr4_ca_drv;
+	unsigned int phy_ddr4_ck_drv;
+	unsigned int phy_ddr4_dq_drv;
+	unsigned int phy_ddr4_odt;
+
+	unsigned int ca_skew[15];
+	unsigned int cs0_skew[44];
+	unsigned int cs1_skew[44];
+
+	unsigned int available;
+};
+
+struct rk3328_ddr_de_skew_setting {
+	unsigned int ca_de_skew[30];
+	unsigned int cs0_de_skew[84];
+	unsigned int cs1_de_skew[84];
+};
+
+struct rk3328_dmcfreq {
+	struct device *dev;
+	struct devfreq *devfreq;
+	struct devfreq_simple_ondemand_data ondemand_data;
+	struct clk *dmc_clk;
+	struct devfreq_event_dev *edev;
+	struct mutex lock;
+	struct regulator *vdd_center;
+	unsigned long rate, target_rate;
+	unsigned long volt, target_volt;
+
+	int (*set_auto_self_refresh)(u32 en);
+};
+
+static void
+rk3328_de_skew_setting_2_register(struct rk3328_ddr_de_skew_setting *de_skew,
+				  struct rk3328_ddr_dts_config_timing *tim)
+{
+	u32 n;
+	u32 offset;
+	u32 shift;
+
+	memset_io(tim->ca_skew, 0, sizeof(tim->ca_skew));
+	memset_io(tim->cs0_skew, 0, sizeof(tim->cs0_skew));
+	memset_io(tim->cs1_skew, 0, sizeof(tim->cs1_skew));
+
+	/* CA de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->ca_de_skew); n++) {
+		offset = n / 2;
+		shift = n % 2;
+		/* 0 => 4; 1 => 0 */
+		shift = (shift == 0) ? 4 : 0;
+		tim->ca_skew[offset] &= ~(0xf << shift);
+		tim->ca_skew[offset] |= (de_skew->ca_de_skew[n] << shift);
+	}
+
+	/* CS0 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs0_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs0_skew[offset] &= ~(0xf << shift);
+		tim->cs0_skew[offset] |= (de_skew->cs0_de_skew[n] << shift);
+	}
+
+	/* CS1 data de-skew */
+	for (n = 0; n < ARRAY_SIZE(de_skew->cs1_de_skew); n++) {
+		offset = ((n / 21) * 11) + ((n % 21) / 2);
+		shift = ((n % 21) % 2);
+		if ((n % 21) == 20)
+			shift = 0;
+		else
+			/* 0 => 4; 1 => 0 */
+			shift = (shift == 0) ? 4 : 0;
+		tim->cs1_skew[offset] &= ~(0xf << shift);
+		tim->cs1_skew[offset] |= (de_skew->cs1_de_skew[n] << shift);
+	}
+}
+
+static void of_get_rk3328_timings(struct device *dev,
+				  struct device_node *np, uint32_t *timing)
+{
+	struct device_node *np_tim;
+	u32 *p;
+	struct rk3328_ddr_dts_config_timing *dts_timing;
+	struct rk3328_ddr_de_skew_setting *de_skew;
+	int ret = 0;
+	u32 i;
+
+	dts_timing =
+		(struct rk3328_ddr_dts_config_timing *)(timing +
+							DTS_PAR_OFFSET / 4);
+
+	np_tim = of_parse_phandle(np, "ddr_timing", 0);
+	if (!np_tim) {
+		ret = -EINVAL;
+		goto end;
+	}
+	de_skew = kmalloc(sizeof(*de_skew), GFP_KERNEL);
+	if (!de_skew) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	p = (u32 *)dts_timing;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->ca_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_ca_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_ca_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs0_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs0_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs0_timing[i],
+					p + i);
+	}
+	p = (u32 *)de_skew->cs1_de_skew;
+	for (i = 0; i < ARRAY_SIZE(rk3328_dts_cs1_timing); i++) {
+		ret |= of_property_read_u32(np_tim, rk3328_dts_cs1_timing[i],
+					p + i);
+	}
+	if (!ret)
+		rk3328_de_skew_setting_2_register(de_skew, dts_timing);
+
+	kfree(de_skew);
+end:
+	if (!ret) {
+		dts_timing->available = 1;
+	} else {
+		dts_timing->available = 0;
+		dev_err(dev, "of_get_ddr_timings: fail\n");
+	}
+
+	of_node_put(np_tim);
+}
+
+static int rockchip_ddr_set_auto_self_refresh(uint32_t en)
+{
+	struct arm_smccc_res res;
+
+	ddr_psci_param->sr_idle_en = en;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_SET_AT_SR,
+		      0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static int rk3328_dmc_init(struct platform_device *pdev,
+			   struct rk3328_dmcfreq *dmcfreq)
+{
+	struct arm_smccc_res res;
+	u32 size, page_num;
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      0, 0, ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION,
+		      0, 0, 0, 0, &res);
+	if (res.a0 || (res.a1 < 0x101)) {
+		dev_err(&pdev->dev,
+			"trusted firmware need to update or is invalid\n");
+		return -ENXIO;
+	}
+
+	dev_notice(&pdev->dev, "current ATF version 0x%lx\n", res.a1);
+
+	/*
+	 * first 4KB is used for interface parameters
+	 * after 4KB * N is dts parameters
+	 */
+	size = sizeof(struct rk3328_ddr_dts_config_timing);
+	page_num = DIV_ROUND_UP(size, 4096) + 1;
+
+	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
+		      page_num, SHARE_PAGE_TYPE_DDR, 0,
+		      0, 0, 0, 0, &res);
+	if (res.a0 != 0) {
+		dev_err(&pdev->dev, "no ATF memory for init\n");
+		return -ENOMEM;
+	}
+
+	ddr_psci_param = ioremap(res.a1, page_num << 12);
+	of_get_rk3328_timings(&pdev->dev, pdev->dev.of_node,
+			      (uint32_t *)ddr_psci_param);
+
+	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
+		      SHARE_PAGE_TYPE_DDR, 0, ROCKCHIP_SIP_CONFIG_DRAM_INIT,
+		      0, 0, 0, 0, &res);
+	if (res.a0) {
+		dev_err(&pdev->dev, "Rockchip dram init error %lx\n", res.a0);
+		return -ENOMEM;
+	}
+
+	dmcfreq->set_auto_self_refresh = rockchip_ddr_set_auto_self_refresh;
+
+	return 0;
+}
+
+static int rk3328_dmcfreq_target(struct device *dev, unsigned long *freq,
+				 u32 flags)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	struct dev_pm_opp *opp;
+	unsigned long old_clk_rate = dmcfreq->rate;
+	unsigned long target_volt, target_rate;
+	int err;
+
+	opp = devfreq_recommended_opp(dev, freq, flags);
+	if (IS_ERR(opp))
+		return PTR_ERR(opp);
+
+	target_rate = dev_pm_opp_get_freq(opp);
+	target_volt = dev_pm_opp_get_voltage(opp);
+	dev_pm_opp_put(opp);
+
+	if (dmcfreq->rate == target_rate)
+		return 0;
+
+	mutex_lock(&dmcfreq->lock);
+
+	/*
+	 * If frequency scaling from low to high, adjust voltage first.
+	 * If frequency scaling from high to low, adjust frequency first.
+	 */
+	if (old_clk_rate < target_rate) {
+		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
+					    target_volt);
+		if (err) {
+			dev_err(dev, "Cannot set voltage %lu uV\n",
+				target_volt);
+			goto out;
+		}
+	}
+
+	err = clk_set_rate(dmcfreq->dmc_clk, target_rate);
+	if (err) {
+		dev_err(dev, "Cannot set frequency %lu (%d)\n", target_rate,
+			err);
+		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
+				      dmcfreq->volt);
+		goto out;
+	}
+
+	/*
+	 * Check the dpll rate,
+	 * There only two result we will get,
+	 * 1. Ddr frequency scaling fail, we still get the old rate.
+	 * 2. Ddr frequency scaling sucessful, we get the rate we set.
+	 */
+	dmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);
+
+	/* If get the incorrect rate, set voltage to old value. */
+	if (dmcfreq->rate != target_rate) {
+		dev_err(dev, "Got wrong frequency, Request %lu, Current %lu\n",
+			target_rate, dmcfreq->rate);
+		regulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,
+				      dmcfreq->volt);
+		goto out;
+	} else if (old_clk_rate > target_rate)
+		err = regulator_set_voltage(dmcfreq->vdd_center, target_volt,
+					    target_volt);
+	if (err)
+		dev_err(dev, "Cannot set voltage %lu uV\n", target_volt);
+
+	dmcfreq->rate = target_rate;
+	dmcfreq->volt = target_volt;
+
+out:
+	mutex_unlock(&dmcfreq->lock);
+	return err;
+}
+
+static int rk3328_dmcfreq_get_dev_status(struct device *dev,
+					 struct devfreq_dev_status *stat)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	struct devfreq_event_data edata;
+	int ret = 0;
+
+	ret = devfreq_event_get_event(dmcfreq->edev, &edata);
+	if (ret < 0)
+		return ret;
+
+	stat->current_frequency = dmcfreq->rate;
+	stat->busy_time = edata.load_count;
+	stat->total_time = edata.total_count;
+
+	return ret;
+}
+
+static int rk3328_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+
+	*freq = dmcfreq->rate;
+
+	return 0;
+}
+
+static struct devfreq_dev_profile rk3328_devfreq_dmc_profile = {
+	.polling_ms	= 200,
+	.target		= rk3328_dmcfreq_target,
+	.get_dev_status	= rk3328_dmcfreq_get_dev_status,
+	.get_cur_freq	= rk3328_dmcfreq_get_cur_freq,
+};
+
+static __maybe_unused int rk3328_dmcfreq_suspend(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_disable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to disable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_suspend_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend the devfreq devices\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static __maybe_unused int rk3328_dmcfreq_resume(struct device *dev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ret = devfreq_event_enable_edev(dmcfreq->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable the devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = devfreq_resume_device(dmcfreq->devfreq);
+	if (ret < 0) {
+		dev_err(dev, "failed to resume the devfreq devices\n");
+		return ret;
+	}
+	return ret;
+}
+
+static SIMPLE_DEV_PM_OPS(rk3328_dmcfreq_pm, rk3328_dmcfreq_suspend,
+			 rk3328_dmcfreq_resume);
+
+static int rk3328_dmcfreq_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct rk3328_dmcfreq *data;
+	struct dev_pm_opp *opp;
+	int ret;
+
+	data = devm_kzalloc(dev, sizeof(struct rk3328_dmcfreq), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mutex_init(&data->lock);
+
+	data->vdd_center = devm_regulator_get(dev, "center");
+	if (IS_ERR(data->vdd_center)) {
+		if (PTR_ERR(data->vdd_center) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_err(dev, "Cannot get the regulator \"center\"\n");
+		return PTR_ERR(data->vdd_center);
+	}
+
+	data->dmc_clk = devm_clk_get(dev, "dmc_clk");
+	if (IS_ERR(data->dmc_clk)) {
+		if (PTR_ERR(data->dmc_clk) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		dev_err(dev, "Cannot get the clk dmc_clk\n");
+		return PTR_ERR(data->dmc_clk);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+	data->edev = devfreq_event_get_edev_by_phandle(dev, 0);
+#else
+	data->edev = devfreq_event_get_edev_by_phandle(dev, "devfreq-events", 0);
+#endif
+	if (IS_ERR(data->edev))
+		return -EPROBE_DEFER;
+
+	ret = devfreq_event_enable_edev(data->edev);
+	if (ret < 0) {
+		dev_err(dev, "failed to enable devfreq-event devices\n");
+		return ret;
+	}
+
+	ret = rk3328_dmc_init(pdev, data);
+	if (ret)
+		return ret;
+
+	/*
+	 * We add a devfreq driver to our parent since it has a device tree node
+	 * with operating points.
+	 */
+	if (dev_pm_opp_of_add_table(dev)) {
+		dev_err(dev, "Invalid operating-points in device tree.\n");
+		return -EINVAL;
+	}
+
+	of_property_read_u32(np, "upthreshold",
+			     &data->ondemand_data.upthreshold);
+	of_property_read_u32(np, "downdifferential",
+			     &data->ondemand_data.downdifferential);
+
+	data->rate = clk_get_rate(data->dmc_clk);
+
+	opp = devfreq_recommended_opp(dev, &data->rate, 0);
+	if (IS_ERR(opp)) {
+		ret = PTR_ERR(opp);
+		goto err_free_opp;
+	}
+
+	data->rate = dev_pm_opp_get_freq(opp);
+	data->volt = dev_pm_opp_get_voltage(opp);
+	dev_pm_opp_put(opp);
+
+	rk3328_devfreq_dmc_profile.initial_freq = data->rate;
+
+	data->devfreq = devm_devfreq_add_device(dev,
+					   &rk3328_devfreq_dmc_profile,
+					   DEVFREQ_GOV_SIMPLE_ONDEMAND,
+					   &data->ondemand_data);
+	if (IS_ERR(data->devfreq)) {
+		ret = PTR_ERR(data->devfreq);
+		goto err_free_opp;
+	}
+
+	devm_devfreq_register_opp_notifier(dev, data->devfreq);
+
+	data->dev = dev;
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+
+err_free_opp:
+	dev_pm_opp_of_remove_table(&pdev->dev);
+	return ret;
+}
+
+static int rk3328_dmcfreq_remove(struct platform_device *pdev)
+{
+	struct rk3328_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);
+
+	/*
+	 * Before remove the opp table we need to unregister the opp notifier.
+	 */
+	devm_devfreq_unregister_opp_notifier(dmcfreq->dev, dmcfreq->devfreq);
+	dev_pm_opp_of_remove_table(dmcfreq->dev);
+
+	return 0;
+}
+
+static const struct of_device_id rk3328dmc_devfreq_of_match[] = {
+	{ .compatible = "rockchip,rk3328-dmc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, rk3328dmc_devfreq_of_match);
+
+static struct platform_driver rk3328_dmcfreq_driver = {
+	.probe	= rk3328_dmcfreq_probe,
+	.remove = rk3328_dmcfreq_remove,
+	.driver = {
+		.name	= "rk3328-dmc-freq",
+		.pm	= &rk3328_dmcfreq_pm,
+		.of_match_table = rk3328dmc_devfreq_of_match,
+	},
+};
+module_platform_driver(rk3328_dmcfreq_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Lin Huang <hl@rock-chips.com>");
+MODULE_DESCRIPTION("RK3328 dmcfreq driver with devfreq framework");
diff --git a/target/linux/rockchip/files/include/dt-bindings/clock/rockchip-ddr.h b/target/linux/rockchip/files/include/dt-bindings/clock/rockchip-ddr.h
new file mode 100644
index 0000000000..b065432e77
--- /dev/null
+++ b/target/linux/rockchip/files/include/dt-bindings/clock/rockchip-ddr.h
@@ -0,0 +1,63 @@
+/*
+ *
+ * Copyright (C) 2017 ROCKCHIP, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+#define _DT_BINDINGS_CLOCK_ROCKCHIP_DDR_H
+
+#define DDR2_DEFAULT	(0)
+
+#define DDR3_800D	(0)	/* 5-5-5 */
+#define DDR3_800E	(1)	/* 6-6-6 */
+#define DDR3_1066E	(2)	/* 6-6-6 */
+#define DDR3_1066F	(3)	/* 7-7-7 */
+#define DDR3_1066G	(4)	/* 8-8-8 */
+#define DDR3_1333F	(5)	/* 7-7-7 */
+#define DDR3_1333G	(6)	/* 8-8-8 */
+#define DDR3_1333H	(7)	/* 9-9-9 */
+#define DDR3_1333J	(8)	/* 10-10-10 */
+#define DDR3_1600G	(9)	/* 8-8-8 */
+#define DDR3_1600H	(10)	/* 9-9-9 */
+#define DDR3_1600J	(11)	/* 10-10-10 */
+#define DDR3_1600K	(12)	/* 11-11-11 */
+#define DDR3_1866J	(13)	/* 10-10-10 */
+#define DDR3_1866K	(14)	/* 11-11-11 */
+#define DDR3_1866L	(15)	/* 12-12-12 */
+#define DDR3_1866M	(16)	/* 13-13-13 */
+#define DDR3_2133K	(17)	/* 11-11-11 */
+#define DDR3_2133L	(18)	/* 12-12-12 */
+#define DDR3_2133M	(19)	/* 13-13-13 */
+#define DDR3_2133N	(20)	/* 14-14-14 */
+#define DDR3_DEFAULT	(21)
+#define DDR_DDR2	(22)
+#define DDR_LPDDR	(23)
+#define DDR_LPDDR2	(24)
+
+#define DDR4_1600J	(0)	/* 10-10-10 */
+#define DDR4_1600K	(1)	/* 11-11-11 */
+#define DDR4_1600L	(2)	/* 12-12-12 */
+#define DDR4_1866L	(3)	/* 12-12-12 */
+#define DDR4_1866M	(4)	/* 13-13-13 */
+#define DDR4_1866N	(5)	/* 14-14-14 */
+#define DDR4_2133N	(6)	/* 14-14-14 */
+#define DDR4_2133P	(7)	/* 15-15-15 */
+#define DDR4_2133R	(8)	/* 16-16-16 */
+#define DDR4_2400P	(9)	/* 15-15-15 */
+#define DDR4_2400R	(10)	/* 16-16-16 */
+#define DDR4_2400U	(11)	/* 18-18-18 */
+#define DDR4_DEFAULT	(12)
+
+#define PAUSE_CPU_STACK_SIZE	16
+
+#endif
diff --git a/target/linux/rockchip/files/include/dt-bindings/memory/rk3328-dram.h b/target/linux/rockchip/files/include/dt-bindings/memory/rk3328-dram.h
new file mode 100644
index 0000000000..171f41c256
--- /dev/null
+++ b/target/linux/rockchip/files/include/dt-bindings/memory/rk3328-dram.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+#define _DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H
+
+#define DDR3_DS_34ohm			(34)
+#define DDR3_DS_40ohm			(40)
+
+#define DDR3_ODT_DIS			(0)
+#define DDR3_ODT_40ohm			(40)
+#define DDR3_ODT_60ohm			(60)
+#define DDR3_ODT_120ohm			(120)
+
+#define LP2_DS_34ohm			(34)
+#define LP2_DS_40ohm			(40)
+#define LP2_DS_48ohm			(48)
+#define LP2_DS_60ohm			(60)
+#define LP2_DS_68_6ohm			(68)	/* optional */
+#define LP2_DS_80ohm			(80)
+#define LP2_DS_120ohm			(120)	/* optional */
+
+#define LP3_DS_34ohm			(34)
+#define LP3_DS_40ohm			(40)
+#define LP3_DS_48ohm			(48)
+#define LP3_DS_60ohm			(60)
+#define LP3_DS_80ohm			(80)
+#define LP3_DS_34D_40U			(3440)
+#define LP3_DS_40D_48U			(4048)
+#define LP3_DS_34D_48U			(3448)
+
+#define LP3_ODT_DIS			(0)
+#define LP3_ODT_60ohm			(60)
+#define LP3_ODT_120ohm			(120)
+#define LP3_ODT_240ohm			(240)
+
+#define LP4_PDDS_40ohm			(40)
+#define LP4_PDDS_48ohm			(48)
+#define LP4_PDDS_60ohm			(60)
+#define LP4_PDDS_80ohm			(80)
+#define LP4_PDDS_120ohm			(120)
+#define LP4_PDDS_240ohm			(240)
+
+#define LP4_DQ_ODT_40ohm		(40)
+#define LP4_DQ_ODT_48ohm		(48)
+#define LP4_DQ_ODT_60ohm		(60)
+#define LP4_DQ_ODT_80ohm		(80)
+#define LP4_DQ_ODT_120ohm		(120)
+#define LP4_DQ_ODT_240ohm		(240)
+#define LP4_DQ_ODT_DIS			(0)
+
+#define LP4_CA_ODT_40ohm		(40)
+#define LP4_CA_ODT_48ohm		(48)
+#define LP4_CA_ODT_60ohm		(60)
+#define LP4_CA_ODT_80ohm		(80)
+#define LP4_CA_ODT_120ohm		(120)
+#define LP4_CA_ODT_240ohm		(240)
+#define LP4_CA_ODT_DIS			(0)
+
+#define DDR4_DS_34ohm			(34)
+#define DDR4_DS_48ohm			(48)
+#define DDR4_RTT_NOM_DIS		(0)
+#define DDR4_RTT_NOM_60ohm		(60)
+#define DDR4_RTT_NOM_120ohm		(120)
+#define DDR4_RTT_NOM_40ohm		(40)
+#define DDR4_RTT_NOM_240ohm		(240)
+#define DDR4_RTT_NOM_48ohm		(48)
+#define DDR4_RTT_NOM_80ohm		(80)
+#define DDR4_RTT_NOM_34ohm		(34)
+
+#define PHY_DDR3_RON_RTT_DISABLE	(0)
+#define PHY_DDR3_RON_RTT_451ohm		(1)
+#define PHY_DDR3_RON_RTT_225ohm		(2)
+#define PHY_DDR3_RON_RTT_150ohm		(3)
+#define PHY_DDR3_RON_RTT_112ohm		(4)
+#define PHY_DDR3_RON_RTT_90ohm		(5)
+#define PHY_DDR3_RON_RTT_75ohm		(6)
+#define PHY_DDR3_RON_RTT_64ohm		(7)
+#define PHY_DDR3_RON_RTT_56ohm		(16)
+#define PHY_DDR3_RON_RTT_50ohm		(17)
+#define PHY_DDR3_RON_RTT_45ohm		(18)
+#define PHY_DDR3_RON_RTT_41ohm		(19)
+#define PHY_DDR3_RON_RTT_37ohm		(20)
+#define PHY_DDR3_RON_RTT_34ohm		(21)
+#define PHY_DDR3_RON_RTT_33ohm		(22)
+#define PHY_DDR3_RON_RTT_30ohm		(23)
+#define PHY_DDR3_RON_RTT_28ohm		(24)
+#define PHY_DDR3_RON_RTT_26ohm		(25)
+#define PHY_DDR3_RON_RTT_25ohm		(26)
+#define PHY_DDR3_RON_RTT_23ohm		(27)
+#define PHY_DDR3_RON_RTT_22ohm		(28)
+#define PHY_DDR3_RON_RTT_21ohm		(29)
+#define PHY_DDR3_RON_RTT_20ohm		(30)
+#define PHY_DDR3_RON_RTT_19ohm		(31)
+
+#define PHY_DDR4_LPDDR3_RON_RTT_DISABLE (0)
+#define PHY_DDR4_LPDDR3_RON_RTT_480ohm	(1)
+#define PHY_DDR4_LPDDR3_RON_RTT_240ohm	(2)
+#define PHY_DDR4_LPDDR3_RON_RTT_160ohm	(3)
+#define PHY_DDR4_LPDDR3_RON_RTT_120ohm	(4)
+#define PHY_DDR4_LPDDR3_RON_RTT_96ohm	(5)
+#define PHY_DDR4_LPDDR3_RON_RTT_80ohm	(6)
+#define PHY_DDR4_LPDDR3_RON_RTT_68ohm	(7)
+#define PHY_DDR4_LPDDR3_RON_RTT_60ohm	(16)
+#define PHY_DDR4_LPDDR3_RON_RTT_53ohm	(17)
+#define PHY_DDR4_LPDDR3_RON_RTT_48ohm	(18)
+#define PHY_DDR4_LPDDR3_RON_RTT_43ohm	(19)
+#define PHY_DDR4_LPDDR3_RON_RTT_40ohm	(20)
+#define PHY_DDR4_LPDDR3_RON_RTT_37ohm	(21)
+#define PHY_DDR4_LPDDR3_RON_RTT_34ohm	(22)
+#define PHY_DDR4_LPDDR3_RON_RTT_32ohm	(23)
+#define PHY_DDR4_LPDDR3_RON_RTT_30ohm	(24)
+#define PHY_DDR4_LPDDR3_RON_RTT_28ohm	(25)
+#define PHY_DDR4_LPDDR3_RON_RTT_26ohm	(26)
+#define PHY_DDR4_LPDDR3_RON_RTT_25ohm	(27)
+#define PHY_DDR4_LPDDR3_RON_RTT_24ohm	(28)
+#define PHY_DDR4_LPDDR3_RON_RTT_22ohm	(29)
+#define PHY_DDR4_LPDDR3_RON_RTT_21ohm	(30)
+#define PHY_DDR4_LPDDR3_RON_RTT_20ohm	(31)
+
+#endif /*_DT_BINDINGS_DRAM_ROCKCHIP_RK3328_H*/
diff --git a/target/linux/rockchip/image/Makefile b/target/linux/rockchip/image/Makefile
index f5fdff637f..3741bee8cc 100644
--- a/target/linux/rockchip/image/Makefile
+++ b/target/linux/rockchip/image/Makefile
@@ -45,6 +45,20 @@ define Build/pine64-img
 	dd if="$(STAGING_DIR_IMAGE)"/$(UBOOT_DEVICE_NAME)-u-boot.itb of="$@" seek=16384 conv=notrunc
 endef
 
+define Build/pine64-bin
+	# This is a copy of pine64-img, but uses rockchip ddrloader
+
+	$(SCRIPT_DIR)/gen_image_generic.sh \
+		$@ \
+		$(CONFIG_TARGET_KERNEL_PARTSIZE) $@.boot \
+		$(CONFIG_TARGET_ROOTFS_PARTSIZE) $(IMAGE_ROOTFS) \
+		32768
+
+	dd if="$(STAGING_DIR_IMAGE)"/$(UBOOT_DEVICE_NAME)-idbloader.bin of="$@" seek=64 conv=notrunc
+	dd if="$(STAGING_DIR_IMAGE)"/$(UBOOT_DEVICE_NAME)-uboot.img of="$@" seek=16384 conv=notrunc
+	dd if="$(STAGING_DIR_IMAGE)"/$(UBOOT_DEVICE_NAME)-trust.bin of="$@" seek=24576 conv=notrunc
+endef
+
 ### Devices ###
 define Device/Default
   PROFILES := Default
diff --git a/target/linux/rockchip/image/armv8.mk b/target/linux/rockchip/image/armv8.mk
index 24b1c38137..b3ef5a28d4 100644
--- a/target/linux/rockchip/image/armv8.mk
+++ b/target/linux/rockchip/image/armv8.mk
@@ -7,11 +7,21 @@ define Device/friendlyarm_nanopi-r2s
   DEVICE_MODEL := NanoPi R2S
   SOC := rk3328
   UBOOT_DEVICE_NAME := nanopi-r2s-rk3328
-  IMAGE/sysupgrade.img.gz := boot-common | boot-script nanopi-r2s | pine64-img | gzip | append-metadata
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script nanopi-r2s | pine64-bin | gzip | append-metadata
   DEVICE_PACKAGES := kmod-usb-net-rtl8152
 endef
 TARGET_DEVICES += friendlyarm_nanopi-r2s
 
+define Device/friendlyarm_nanopi-r4s
+  DEVICE_VENDOR := FriendlyARM
+  DEVICE_MODEL := NanoPi R4S
+  SOC := rk3399
+  UBOOT_DEVICE_NAME := nanopi-r4s-rk3399
+  IMAGE/sysupgrade.img.gz := boot-common | boot-script nanopi-r4s | pine64-img | gzip | append-metadata
+  DEVICE_PACKAGES := kmod-r8169 -urngd
+endef
+TARGET_DEVICES += friendlyarm_nanopi-r4s
+
 define Device/pine64_rockpro64
   DEVICE_VENDOR := Pine64
   DEVICE_MODEL := RockPro64
diff --git a/target/linux/rockchip/image/nanopi-r4s.bootscript b/target/linux/rockchip/image/nanopi-r4s.bootscript
new file mode 100644
index 0000000000..abe9c24ee3
--- /dev/null
+++ b/target/linux/rockchip/image/nanopi-r4s.bootscript
@@ -0,0 +1,8 @@
+part uuid mmc ${devnum}:2 uuid
+
+setenv bootargs "console=ttyS2,1500000 earlycon=uart8250,mmio32,0xff1a0000 root=PARTUUID=${uuid} rw rootwait"
+
+load mmc ${devnum}:1 ${fdt_addr_r} rockchip.dtb
+load mmc ${devnum}:1 ${kernel_addr_r} kernel.img
+
+booti ${kernel_addr_r} - ${fdt_addr_r}
diff --git a/target/linux/rockchip/patches-5.10/005-rockchip-rk3328-add-compatible-to-NanoPi-R2S-etherne.patch b/target/linux/rockchip/patches-5.10/005-rockchip-rk3328-add-compatible-to-NanoPi-R2S-etherne.patch
new file mode 100644
index 0000000000..897a42fea2
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/005-rockchip-rk3328-add-compatible-to-NanoPi-R2S-etherne.patch
@@ -0,0 +1,25 @@
+From bc6c96d850419e71dbc9b0094ccc9b668ba9be43 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Mon, 28 Sep 2020 22:54:52 +0200
+Subject: [PATCH] rockchip: rk3328: add compatible to NanoPi R2S ethernet PHY
+
+This adds the compatible property to the NanoPi R2S ethernet PHY node.
+Otherwise, the PHY might not be probed, as the PHY ID reads all 0xff
+when it is still in reset.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+@@ -134,6 +134,8 @@
+ 		#size-cells = <0>;
+ 
+ 		rtl8211e: ethernet-phy@1 {
++			compatible = "ethernet-phy-id001c.c915",
++				     "ethernet-phy-ieee802.3-c22";
+ 			reg = <1>;
+ 			pinctrl-0 = <&eth_phy_reset_pin>;
+ 			pinctrl-names = "default";
diff --git a/target/linux/rockchip/patches-5.10/105-mmc-core-set-initial-signal-voltage-on-power-off.patch b/target/linux/rockchip/patches-5.10/105-mmc-core-set-initial-signal-voltage-on-power-off.patch
new file mode 100644
index 0000000000..2a0f8d9bd0
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/105-mmc-core-set-initial-signal-voltage-on-power-off.patch
@@ -0,0 +1,35 @@
+From 0d329112c709d6cfedf0fffb19f0cc6b19043f6b Mon Sep 17 00:00:00 2001
+From: Jonas Karlman <jonas@kwiboo.se>
+Date: Wed, 20 Feb 2019 07:38:34 +0000
+Subject: [PATCH] mmc: core: set initial signal voltage on power off
+
+Some boards have SD card connectors where the power rail cannot be switched
+off by the driver. If the card has not been power cycled, it may still be
+using 1.8V signaling after a warm re-boot. Bootroms expecting 3.3V signaling
+will fail to boot from a UHS card that continue to use 1.8V signaling.
+
+Set initial signal voltage in mmc_power_off() to allow re-boot to function.
+
+This fixes re-boot with UHS cards on Asus Tinker Board (Rockchip RK3288),
+same issue have been seen on some Rockchip RK3399 boards.
+
+I am sending this as a RFC because I have no insights into SD/MMC subsystem,
+this change fix a re-boot issue on my boards and does not break emmc/sdio.
+Is this an acceptable workaround? Any advice is appreciated.
+
+Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
+---
+ drivers/mmc/core/core.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/mmc/core/core.c
++++ b/drivers/mmc/core/core.c
+@@ -1351,6 +1351,8 @@ void mmc_power_off(struct mmc_host *host
+ 
+ 	mmc_pwrseq_power_off(host);
+ 
++	mmc_set_initial_signal_voltage(host);
++
+ 	host->ios.clock = 0;
+ 	host->ios.vdd = 0;
+ 
diff --git a/target/linux/rockchip/patches-5.10/200-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch b/target/linux/rockchip/patches-5.10/200-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
new file mode 100644
index 0000000000..69c880db9f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/200-rockchip-rk3399-Add-support-for-FriendlyARM-NanoPi-R.patch
@@ -0,0 +1,218 @@
+From 11c2b38cf0a04b0edb3eabae24fb1484489725e2 Mon Sep 17 00:00:00 2001
+From: Tianling Shen <cnsztl@gmail.com>
+Date: Fri, 8 Jan 2021 07:12:30 +0000
+Subject: [PATCH] rockchip: rk3399: Add support for FriendlyARM NanoPi R4S
+
+This adds support for the NanoPi R4S from FriendlyArm.
+
+Rockchip RK3399 SoC
+1GB DDR3 or 4GB LPDDR4 RAM
+Gigabit Ethernet (WAN)
+Gigabit Ethernet (PCIe) (LAN)
+USB 3.0 Host Port x 2
+MicroSD slot
+Reset button
+WAN - LAN - SYS LED
+
+Signed-off-by: Tianling Shen <cnsztl@gmail.com>
+Co-authored-by: Jensen Huang <jensenhuang@friendlyarm.com>
+Signed-off-by: Jensen Huang <jensenhuang@friendlyarm.com>
+Co-authored-by: Marty Jones <mj8263788@gmail.com>
+Signed-off-by: Marty Jones <mj8263788@gmail.com>
+---
+ arch/arm64/boot/dts/rockchip/Makefile         |   1 +
+ .../boot/dts/rockchip/rk3399-nanopi-r4s.dts   | 178 ++++++++++++++++++
+ 2 files changed, 179 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/rockchip/rk3399-nanopi-r4s.dts
+
+--- a/arch/arm64/boot/dts/rockchip/Makefile
++++ b/arch/arm64/boot/dts/rockchip/Makefile
+@@ -30,6 +30,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-le
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopc-t4.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopi-m4.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopi-neo4.dtb
++dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopi-r4s.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-orangepi.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-pinebook-pro.dtb
+ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-puma-haikou.dtb
+--- /dev/null
++++ b/arch/arm64/boot/dts/rockchip/rk3399-nanopi-r4s.dts
+@@ -0,0 +1,178 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2020 Jensen Huang <jensenhuang@friendlyarm.com>
++ * Copyright (c) 2020 Marty Jones <mj8263788@gmail.com>
++ * Copyright (c) 2020 Tianling Shen <cnsztl@gmail.com>
++ */
++
++/dts-v1/;
++#include "rk3399-nanopi4.dtsi"
++
++/ {
++	model = "FriendlyElec NanoPi R4S";
++	compatible = "friendlyarm,nanopi-r4s", "rockchip,rk3399";
++
++	aliases {
++		led-boot = &sys_led;
++		led-failsafe = &sys_led;
++		led-running = &sys_led;
++		led-upgrade = &sys_led;
++	};
++
++	/delete-node/ gpio-leds;
++	gpio-leds {
++		compatible = "gpio-leds";
++		pinctrl-0 = <&lan_led_pin>, <&sys_led_pin>, <&wan_led_pin>;
++		pinctrl-names = "default";
++
++		lan_led: led-0 {
++			gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:green:lan";
++		};
++
++		sys_led: led-1 {
++			gpios = <&gpio0 RK_PB5 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:red:sys";
++		};
++
++		wan_led: led-2 {
++			gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
++			label = "nanopi-r4s:green:wan";
++		};
++	};
++
++	/delete-node/ gpio-keys;
++	gpio-keys {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&reset_button_pin>;
++
++		reset {
++			debounce-interval = <50>;
++			gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_LOW>;
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++		};
++	};
++
++	vdd_5v: vdd-5v {
++		compatible = "regulator-fixed";
++		regulator-name = "vdd_5v";
++		regulator-always-on;
++		regulator-boot-on;
++	};
++
++	fan: pwm-fan {
++		compatible = "pwm-fan";
++		/*
++		 * With 20KHz PWM and an EVERCOOL EC4007H12SA fan, these levels
++		 * work out to 0, ~1200, ~3000, and 5000RPM respectively.
++		 */
++		cooling-levels = <0 12 18 255>;
++		#cooling-cells = <2>;
++		fan-supply = <&vdd_5v>;
++		pwms = <&pwm1 0 50000 0>;
++	};
++};
++
++&cpu_thermal {
++	trips {
++		cpu_warm: cpu_warm {
++			temperature = <55000>;
++			hysteresis = <2000>;
++			type = "active";
++		};
++
++		cpu_hot: cpu_hot {
++			temperature = <65000>;
++			hysteresis = <2000>;
++			type = "active";
++		};
++	};
++
++	cooling-maps {
++		map2 {
++			trip = <&cpu_warm>;
++			cooling-device = <&fan THERMAL_NO_LIMIT 1>;
++		};
++
++		map3 {
++			trip = <&cpu_hot>;
++			cooling-device = <&fan 2 THERMAL_NO_LIMIT>;
++		};
++	};
++};
++
++&emmc_phy {
++	status = "disabled";
++};
++
++&fusb0 {
++	status = "disabled";
++};
++
++&pcie0 {
++	max-link-speed = <1>;
++	num-lanes = <1>;
++	vpcie3v3-supply = <&vcc3v3_sys>;
++
++	pcie@0 {
++		reg = <0x00000000 0 0 0 0>;
++		#address-cells = <3>;
++		#size-cells = <2>;
++	};
++};
++
++&pinctrl {
++	/delete-node/ gpio-leds;
++	gpio-leds {
++		lan_led_pin: lan-led-pin {
++			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		sys_led_pin: sys-led-pin {
++			rockchip,pins = <0 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++
++		wan_led_pin: wan-led-pin {
++			rockchip,pins = <1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
++		};
++	};
++
++	/delete-node/ rockchip-key;
++	rockchip-key {
++		reset_button_pin: reset-button-pin {
++			rockchip,pins = <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
++		};
++	};
++};
++
++&sdhci {
++	status = "disabled";
++};
++
++&sdio0 {
++	status = "disabled";
++};
++
++&sdmmc {
++	sd-uhs-sdr12;
++	sd-uhs-sdr25;
++	sd-uhs-sdr50;
++};
++
++&u2phy0_host {
++	phy-supply = <&vdd_5v>;
++};
++
++&u2phy1_host {
++	status = "disabled";
++};
++
++&usbdrd_dwc3_0 {
++	dr_mode = "host";
++};
++
++&vcc3v3_sys {
++	vin-supply = <&vcc5v0_sys>;
++};
diff --git a/target/linux/rockchip/patches-5.10/201-rockchip-rk3328-add-i2c0-controller-for-nanopi-r2s.patch b/target/linux/rockchip/patches-5.10/201-rockchip-rk3328-add-i2c0-controller-for-nanopi-r2s.patch
new file mode 100644
index 0000000000..28798047fd
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/201-rockchip-rk3328-add-i2c0-controller-for-nanopi-r2s.patch
@@ -0,0 +1,22 @@
+From 3b7eb946b1d640d684a921e53e1e50985ab7eb89 Mon Sep 17 00:00:00 2001
+From: QiuSimons <45143996+QiuSimons@users.noreply.github.com>
+Date: Tue, 4 Aug 2020 20:17:53 +0800
+Subject: [PATCH] rockchip: rk3328: add i2c0 controller for nanopi r2s
+
+---
+ arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts | 4 ++++
+ 1 files changed, 4 insertions(+)
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+@@ -165,6 +165,10 @@
+ 	};
+ };
+ 
++&i2c0 {
++	status = "okay";
++};
++
+ &i2c1 {
+ 	status = "okay";
+ 
diff --git a/target/linux/rockchip/patches-5.10/801-char-add-support-for-rockchip-hardware-random-number.patch b/target/linux/rockchip/patches-5.10/801-char-add-support-for-rockchip-hardware-random-number.patch
new file mode 100644
index 0000000000..16ca6279e7
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/801-char-add-support-for-rockchip-hardware-random-number.patch
@@ -0,0 +1,45 @@
+From e5b5361651940ff5c0c1784dfd0130abec7ab535 Mon Sep 17 00:00:00 2001
+From: wevsty <ty@wevs.org>
+Date: Mon, 24 Aug 2020 02:27:11 +0800
+Subject: [PATCH] char: add support for rockchip hardware random number
+ generator
+
+This patch provides hardware random number generator support for all rockchip SOC.
+
+rockchip-rng.c from  https://github.com/rockchip-linux/kernel/blob/develop-4.4/drivers/char/hw_random/rockchip-rng.c
+
+Signed-off-by: wevsty <ty@wevs.org>
+---
+
+--- a/drivers/char/hw_random/Kconfig
++++ b/drivers/char/hw_random/Kconfig
+@@ -398,6 +398,19 @@ config HW_RANDOM_STM32
+ 
+ 	  If unsure, say N.
+ 
++config HW_RANDOM_ROCKCHIP
++	tristate "Rockchip Random Number Generator support"
++	depends on ARCH_ROCKCHIP
++	default HW_RANDOM
++	help
++	  This driver provides kernel-side support for the Random Number
++	  Generator hardware found on Rockchip cpus.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called rockchip-rng.
++
++	  If unsure, say Y.
++
+ config HW_RANDOM_PIC32
+ 	tristate "Microchip PIC32 Random Number Generator support"
+ 	depends on HW_RANDOM && MACH_PIC32
+--- a/drivers/char/hw_random/Makefile
++++ b/drivers/char/hw_random/Makefile
+@@ -36,6 +36,7 @@ obj-$(CONFIG_HW_RANDOM_IPROC_RNG200) +=
+ obj-$(CONFIG_HW_RANDOM_ST) += st-rng.o
+ obj-$(CONFIG_HW_RANDOM_XGENE) += xgene-rng.o
+ obj-$(CONFIG_HW_RANDOM_STM32) += stm32-rng.o
++obj-$(CONFIG_HW_RANDOM_ROCKCHIP) += rockchip-rng.o
+ obj-$(CONFIG_HW_RANDOM_PIC32) += pic32-rng.o
+ obj-$(CONFIG_HW_RANDOM_MESON) += meson-rng.o
+ obj-$(CONFIG_HW_RANDOM_CAVIUM) += cavium-rng.o cavium-rng-vf.o
diff --git a/target/linux/rockchip/patches-5.10/802-arm64-dts-rockchip-add-hardware-random-number-genera.patch b/target/linux/rockchip/patches-5.10/802-arm64-dts-rockchip-add-hardware-random-number-genera.patch
new file mode 100644
index 0000000000..1de560e33f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/802-arm64-dts-rockchip-add-hardware-random-number-genera.patch
@@ -0,0 +1,50 @@
+From e5b5361651940ff5c0c1784dfd0130abec7ab535 Mon Sep 17 00:00:00 2001
+From: wevsty <ty@wevs.org>
+Date: Mon, 24 Aug 2020 02:27:11 +0800
+Subject: [PATCH] arm64: dts: rockchip: add hardware random number generator
+ for RK3328 and RK3399
+
+Adding Hardware Random Number Generator Resources to the RK3328 and RK3399.
+
+Signed-off-by: wevsty <ty@wevs.org>
+---
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -297,6 +297,17 @@
+ 		status = "disabled";
+ 	};
+ 
++	rng: rng@ff060000 {
++		compatible = "rockchip,cryptov1-rng";
++		reg = <0x0 0xff060000 0x0 0x4000>;
++
++		clocks = <&cru SCLK_CRYPTO>, <&cru HCLK_CRYPTO_SLV>;
++		clock-names = "clk_crypto", "hclk_crypto";
++		assigned-clocks = <&cru SCLK_CRYPTO>, <&cru HCLK_CRYPTO_SLV>;
++		assigned-clock-rates = <150000000>, <100000000>;
++		status = "disabled";
++	};
++
+ 	grf: syscon@ff100000 {
+ 		compatible = "rockchip,rk3328-grf", "syscon", "simple-mfd";
+ 		reg = <0x0 0xff100000 0x0 0x1000>;
+--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+@@ -1906,6 +1906,16 @@
+ 		};
+ 	};
+ 
++	rng: rng@ff8b8000 {
++		compatible = "rockchip,cryptov1-rng";
++		reg = <0x0 0xff8b8000 0x0 0x1000>;
++		clocks = <&cru SCLK_CRYPTO1>, <&cru HCLK_S_CRYPTO1>;
++		clock-names = "clk_crypto", "hclk_crypto";
++		assigned-clocks = <&cru SCLK_CRYPTO1>, <&cru HCLK_S_CRYPTO1>;
++		assigned-clock-rates = <150000000>, <100000000>;
++		status = "okay";
++	};
++
+ 	gpu: gpu@ff9a0000 {
+ 		compatible = "rockchip,rk3399-mali", "arm,mali-t860";
+ 		reg = <0x0 0xff9a0000 0x0 0x10000>;
diff --git a/target/linux/rockchip/patches-5.10/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch b/target/linux/rockchip/patches-5.10/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
new file mode 100644
index 0000000000..a4b8340be4
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
@@ -0,0 +1,44 @@
+From fcd9629c05f373771e85920e1c1d0ab252617878 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 13:53:25 +0800
+Subject: [PATCH] PM / devfreq: rockchip: add devfreq driver for rk3328 dmc
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/Kconfig      |  18 +-
+ drivers/devfreq/Makefile     |   1 +
+ drivers/devfreq/rk3328_dmc.c | 846 +++++++++++++++++++++++++++++++++++
+ 3 files changed, 862 insertions(+), 3 deletions(-)
+ create mode 100644 drivers/devfreq/rk3328_dmc.c
+
+--- a/drivers/devfreq/Kconfig
++++ b/drivers/devfreq/Kconfig
+@@ -131,6 +131,18 @@ config ARM_TEGRA20_DEVFREQ
+ 	  It reads Memory Controller counters and adjusts the operating
+ 	  frequencies and voltages with OPP support.
+ 
++config ARM_RK3328_DMC_DEVFREQ
++	tristate "ARM RK3328 DMC DEVFREQ Driver"
++	depends on ARCH_ROCKCHIP
++	select DEVFREQ_EVENT_ROCKCHIP_DFI
++	select DEVFREQ_GOV_SIMPLE_ONDEMAND
++	select PM_DEVFREQ_EVENT
++	select PM_OPP
++	help
++	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
++
+ config ARM_RK3399_DMC_DEVFREQ
+ 	tristate "ARM RK3399 DMC DEVFREQ Driver"
+ 	depends on (ARCH_ROCKCHIP && HAVE_ARM_SMCCC) || \
+--- a/drivers/devfreq/Makefile
++++ b/drivers/devfreq/Makefile
+@@ -12,6 +12,7 @@ obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+=
+ obj-$(CONFIG_ARM_IMX_BUS_DEVFREQ)	+= imx-bus.o
+ obj-$(CONFIG_ARM_IMX8M_DDRC_DEVFREQ)	+= imx8m-ddrc.o
+ obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
++obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
+ obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
+ obj-$(CONFIG_ARM_TEGRA20_DEVFREQ)	+= tegra20-devfreq.o
+ 
diff --git a/target/linux/rockchip/patches-5.10/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch b/target/linux/rockchip/patches-5.10/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
new file mode 100644
index 0000000000..4e688f8eb4
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
@@ -0,0 +1,218 @@
+From ce6d3614888e6358466f0e84e248177a6bca5258 Mon Sep 17 00:00:00 2001
+From: Tang Yun ping <typ@rock-chips.com>
+Date: Thu, 4 May 2017 20:49:58 +0800
+Subject: [PATCH] clk: rockchip: support setting ddr clock via SIP Version 2
+ APIs
+
+commit 764e893ee82321938fc6f4349e9e7caf06a04410 rockchip.
+
+Signed-off-by: Tang Yun ping <typ@rock-chips.com>
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/clk/rockchip/clk-ddr.c      | 130 ++++++++++++++++++++++++++++
+ drivers/clk/rockchip/clk-rk3328.c   |   7 +-
+ drivers/clk/rockchip/clk.h          |   3 +-
+ include/soc/rockchip/rockchip_sip.h |  11 +++
+ 4 files changed, 147 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
+index 9273bce4d7b6..555aaf4e758d 100644
+--- a/drivers/clk/rockchip/clk-ddr.c
++++ b/drivers/clk/rockchip/clk-ddr.c
+@@ -87,6 +87,133 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
+ 	.get_parent = rockchip_ddrclk_get_parent,
+ };
+ 
++/* See v4.4/include/dt-bindings/display/rk_fb.h */
++#define SCREEN_NULL			0
++#define SCREEN_HDMI			6
++
++static inline int rk_drm_get_lcdc_type(void)
++{
++	return SCREEN_NULL;
++}
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	 /* if need, add parameter after */
++};
++
++struct rockchip_ddrclk_data {
++	u32 inited_flag;
++	void __iomem *share_memory;
++};
++
++static struct rockchip_ddrclk_data ddr_data;
++
++static void rockchip_ddrclk_data_init(void)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      1, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++
++	if (!res.a0) {
++		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
++		ddr_data.inited_flag = 1;
++	}
++}
++
++static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
++					   unsigned long drate,
++					   unsigned long prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = drate;
++	p->lcdc_type = rk_drm_get_lcdc_type();
++	p->wait_flag1 = 1;
++	p->wait_flag0 = 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
++		      0, 0, 0, 0, &res);
++
++	if ((int)res.a1 == -6) {
++		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
++		/* TODO: rockchip_dmcfreq_wait_complete(); */
++	}
++
++	return res.a0;
++}
++
++static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
++			(struct clk_hw *hw, unsigned long parent_rate)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
++					      unsigned long rate,
++					      unsigned long *prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = rate;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
++	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
++	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
++	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
++	.get_parent = rockchip_ddrclk_get_parent,
++};
++
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+ 					 u8 num_parents, int mux_offset,
+@@ -114,6 +241,9 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 	case ROCKCHIP_DDRCLK_SIP:
+ 		init.ops = &rockchip_ddrclk_sip_ops;
+ 		break;
++	case ROCKCHIP_DDRCLK_SIP_V2:
++		init.ops = &rockchip_ddrclk_sip_ops_v2;
++		break;
+ 	default:
+ 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
+ 		kfree(ddrclk);
+diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
+index c186a1985bf4..ac6e6163a232 100644
+--- a/drivers/clk/rockchip/clk-rk3328.c
++++ b/drivers/clk/rockchip/clk-rk3328.c
+@@ -314,9 +314,10 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
+ 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
+ 
+ 	/* PD_DDR */
+-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
+-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
++	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
++			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
++			ROCKCHIP_DDRCLK_SIP_V2),
++
+ 	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
+ 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
+ 	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
+index 2271a84124b0..7405aaf965ec 100644
+--- a/drivers/clk/rockchip/clk.h
++++ b/drivers/clk/rockchip/clk.h
+@@ -362,7 +362,8 @@ struct clk *rockchip_clk_register_mmc(const char *name,
+  * DDRCLK flags, including method of setting the rate
+  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
+  */
+-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
++#define ROCKCHIP_DDRCLK_SIP		0x01
++#define ROCKCHIP_DDRCLK_SIP_V2		0x03
+ 
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
+index c46a9ae2a2ab..fa7e0a2d72cc 100644
+--- a/include/soc/rockchip/rockchip_sip.h
++++ b/include/soc/rockchip/rockchip_sip.h
+@@ -16,5 +16,16 @@
+ #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
++#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
++
++#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
++
++/* Share mem page types */
++typedef enum {
++    SHARE_PAGE_TYPE_INVALID = 0,
++    SHARE_PAGE_TYPE_UARTDBG,
++    SHARE_PAGE_TYPE_DDR,
++    SHARE_PAGE_TYPE_MAX,
++} share_page_type_t;
+ 
+ #endif
diff --git a/target/linux/rockchip/patches-5.10/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch b/target/linux/rockchip/patches-5.10/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
new file mode 100644
index 0000000000..283e4abd2f
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
@@ -0,0 +1,662 @@
+From 4db93c6dad0c71750b86163df2fdb21c35f00d9a Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 12:49:48 +0800
+Subject: [PATCH] PM / devfreq: rockchip-dfi: add more soc support
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/event/rockchip-dfi.c | 554 ++++++++++++++++++++++++---
+ 1 file changed, 505 insertions(+), 49 deletions(-)
+
+--- a/drivers/devfreq/event/rockchip-dfi.c
++++ b/drivers/devfreq/event/rockchip-dfi.c
+@@ -18,25 +18,66 @@
+ #include <linux/list.h>
+ #include <linux/of.h>
+ 
+-#include <soc/rockchip/rk3399_grf.h>
+-
+-#define RK3399_DMC_NUM_CH	2
++#define PX30_PMUGRF_OS_REG2		0x208
+ 
++#define RK3128_GRF_SOC_CON0		0x140
++#define RK3128_GRF_OS_REG1		0x1cc
++#define RK3128_GRF_DFI_WRNUM		0x220
++#define RK3128_GRF_DFI_RDNUM		0x224
++#define RK3128_GRF_DFI_TIMERVAL		0x22c
++#define RK3128_DDR_MONITOR_EN		((1 << (16 + 6)) + (1 << 6))
++#define RK3128_DDR_MONITOR_DISB		((1 << (16 + 6)) + (0 << 6))
++
++#define RK3288_PMU_SYS_REG2		0x9c
++#define RK3288_GRF_SOC_CON4		0x254
++#define RK3288_GRF_SOC_STATUS(n)	(0x280 + (n) * 4)
++#define RK3288_DFI_EN			(0x30003 << 14)
++#define RK3288_DFI_DIS			(0x30000 << 14)
++#define RK3288_LPDDR_SEL		(0x10001 << 13)
++#define RK3288_DDR3_SEL			(0x10000 << 13)
++
++#define RK3328_GRF_OS_REG2		0x5d0
++
++#define RK3368_GRF_DDRC0_CON0		0x600
++#define RK3368_GRF_SOC_STATUS5		0x494
++#define RK3368_GRF_SOC_STATUS6		0x498
++#define RK3368_GRF_SOC_STATUS8		0x4a0
++#define RK3368_GRF_SOC_STATUS9		0x4a4
++#define RK3368_GRF_SOC_STATUS10		0x4a8
++#define RK3368_DFI_EN			(0x30003 << 5)
++#define RK3368_DFI_DIS			(0x30000 << 5)
++
++#define MAX_DMC_NUM_CH			2
++#define READ_DRAMTYPE_INFO(n)		(((n) >> 13) & 0x7)
++#define READ_CH_INFO(n)			(((n) >> 28) & 0x3)
+ /* DDRMON_CTRL */
+-#define DDRMON_CTRL	0x04
+-#define CLR_DDRMON_CTRL	(0x1f0000 << 0)
+-#define LPDDR4_EN	(0x10001 << 4)
+-#define HARDWARE_EN	(0x10001 << 3)
+-#define LPDDR3_EN	(0x10001 << 2)
+-#define SOFTWARE_EN	(0x10001 << 1)
+-#define SOFTWARE_DIS	(0x10000 << 1)
+-#define TIME_CNT_EN	(0x10001 << 0)
++#define DDRMON_CTRL			0x04
++#define CLR_DDRMON_CTRL			(0x3f0000 << 0)
++#define DDR4_EN				(0x10001 << 5)
++#define LPDDR4_EN			(0x10001 << 4)
++#define HARDWARE_EN			(0x10001 << 3)
++#define LPDDR2_3_EN			(0x10001 << 2)
++#define SOFTWARE_EN			(0x10001 << 1)
++#define SOFTWARE_DIS			(0x10000 << 1)
++#define TIME_CNT_EN			(0x10001 << 0)
+ 
+ #define DDRMON_CH0_COUNT_NUM		0x28
+ #define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
+ #define DDRMON_CH1_COUNT_NUM		0x3c
+ #define DDRMON_CH1_DFI_ACCESS_NUM	0x40
+ 
++/* pmu grf */
++#define PMUGRF_OS_REG2			0x308
++
++enum {
++	DDR4 = 0,
++	DDR3 = 3,
++	LPDDR2 = 5,
++	LPDDR3 = 6,
++	LPDDR4 = 7,
++	UNUSED = 0xFF
++};
++
+ struct dmc_usage {
+ 	u32 access;
+ 	u32 total;
+@@ -50,33 +91,261 @@ struct dmc_usage {
+ struct rockchip_dfi {
+ 	struct devfreq_event_dev *edev;
+ 	struct devfreq_event_desc *desc;
+-	struct dmc_usage ch_usage[RK3399_DMC_NUM_CH];
++	struct dmc_usage ch_usage[MAX_DMC_NUM_CH];
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	struct regmap *regmap_pmu;
++	struct regmap *regmap_grf;
++	struct regmap *regmap_pmugrf;
+ 	struct clk *clk;
++	u32 dram_type;
++	/*
++	 * available mask, 1: available, 0: not available
++	 * each bit represent a channel
++	 */
++	u32 ch_msk;
++};
++
++static void rk3128_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_EN);
++}
++
++static void rk3128_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_DISB);
++}
++
++static int rk3128_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3128_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi_wr, dfi_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_WRNUM, &dfi_wr);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_RDNUM, &dfi_rd);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_TIMERVAL, &dfi_timer);
++
++	edata->load_count = (dfi_wr + dfi_rd) * 4;
++	edata->total_count = dfi_timer;
++
++	rk3128_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3128_dfi_ops = {
++	.disable = rk3128_dfi_disable,
++	.enable = rk3128_dfi_enable,
++	.get_event = rk3128_dfi_get_event,
++	.set_event = rk3128_dfi_set_event,
++};
++
++static void rk3288_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_EN);
++}
++
++static void rk3288_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_DIS);
++}
++
++static int rk3288_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3288_dfi_get_busier_ch(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	u32 tmp, max = 0;
++	u32 i, busier_ch = 0;
++	u32 rd_count, wr_count, total_count;
++
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	/* Find out which channel is busier */
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(11 + i * 4), &wr_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(12 + i * 4), &rd_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(14 + i * 4), &total_count);
++		info->ch_usage[i].access = (wr_count + rd_count) * 4;
++		info->ch_usage[i].total = total_count;
++		tmp = info->ch_usage[i].access;
++		if (tmp > max) {
++			busier_ch = i;
++			max = tmp;
++		}
++	}
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return busier_ch;
++}
++
++static int rk3288_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	int busier_ch;
++	unsigned long flags;
++
++	local_irq_save(flags);
++	busier_ch = rk3288_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
++
++	edata->load_count = info->ch_usage[busier_ch].access;
++	edata->total_count = info->ch_usage[busier_ch].total;
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3288_dfi_ops = {
++	.disable = rk3288_dfi_disable,
++	.enable = rk3288_dfi_enable,
++	.get_event = rk3288_dfi_get_event,
++	.set_event = rk3288_dfi_set_event,
++};
++
++static void rk3368_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_EN);
++}
++
++static void rk3368_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_DIS);
++}
++
++static int rk3368_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3368_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi0_wr, dfi0_rd, dfi1_wr, dfi1_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS5, &dfi0_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS6, &dfi0_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS9, &dfi1_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS10, &dfi1_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS8, &dfi_timer);
++
++	edata->load_count = (dfi0_wr + dfi0_rd + dfi1_wr + dfi1_rd) * 2;
++	edata->total_count = dfi_timer;
++
++	rk3368_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3368_dfi_ops = {
++	.disable = rk3368_dfi_disable,
++	.enable = rk3368_dfi_enable,
++	.get_event = rk3368_dfi_get_event,
++	.set_event = rk3368_dfi_set_event,
+ };
+ 
+ static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	void __iomem *dfi_regs = info->regs;
+-	u32 val;
+-	u32 ddr_type;
+-
+-	/* get ddr type */
+-	regmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
+-	ddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &
+-		    RK3399_PMUGRF_DDRTYPE_MASK;
+ 
+ 	/* clear DDRMON_CTRL setting */
+ 	writel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* set ddr type to dfi */
+-	if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)
+-		writel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);
+-	else if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)
++	if (info->dram_type == LPDDR3 || info->dram_type == LPDDR2)
++		writel_relaxed(LPDDR2_3_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == LPDDR4)
+ 		writel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == DDR4)
++		writel_relaxed(DDR4_EN, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* enable count, use software mode */
+ 	writel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);
+@@ -100,12 +369,22 @@ static int rockchip_dfi_get_busier_ch(st
+ 	rockchip_dfi_stop_hardware_counter(edev);
+ 
+ 	/* Find out which channel is busier */
+-	for (i = 0; i < RK3399_DMC_NUM_CH; i++) {
+-		info->ch_usage[i].access = readl_relaxed(dfi_regs +
+-				DDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++
+ 		info->ch_usage[i].total = readl_relaxed(dfi_regs +
+ 				DDRMON_CH0_COUNT_NUM + i * 20);
+-		tmp = info->ch_usage[i].access;
++
++		/* LPDDR4 BL = 16,other DDR type BL = 8 */
++		tmp = readl_relaxed(dfi_regs +
++				DDRMON_CH0_DFI_ACCESS_NUM + i * 20);
++		if (info->dram_type == LPDDR4)
++			tmp *= 8;
++		else
++			tmp *= 4;
++		info->ch_usage[i].access = tmp;
++
+ 		if (tmp > max) {
+ 			busier_ch = i;
+ 			max = tmp;
+@@ -121,7 +400,8 @@ static int rockchip_dfi_disable(struct d
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 
+ 	rockchip_dfi_stop_hardware_counter(edev);
+-	clk_disable_unprepare(info->clk);
++	if (info->clk)
++		clk_disable_unprepare(info->clk);
+ 
+ 	return 0;
+ }
+@@ -131,10 +411,13 @@ static int rockchip_dfi_enable(struct de
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int ret;
+ 
+-	ret = clk_prepare_enable(info->clk);
+-	if (ret) {
+-		dev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);
+-		return ret;
++	if (info->clk) {
++		ret = clk_prepare_enable(info->clk);
++		if (ret) {
++			dev_err(&edev->dev, "failed to enable dfi clk: %d\n",
++				ret);
++			return ret;
++		}
+ 	}
+ 
+ 	rockchip_dfi_start_hardware_counter(edev);
+@@ -151,8 +434,11 @@ static int rockchip_dfi_get_event(struct
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int busier_ch;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	busier_ch = rockchip_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
+ 
+ 	edata->load_count = info->ch_usage[busier_ch].access;
+ 	edata->total_count = info->ch_usage[busier_ch].total;
+@@ -167,22 +453,116 @@ static const struct devfreq_event_ops ro
+ 	.set_event = rockchip_dfi_set_event,
+ };
+ 
+-static const struct of_device_id rockchip_dfi_id_match[] = {
+-	{ .compatible = "rockchip,rk3399-dfi" },
+-	{ },
+-};
+-MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++static __init int px30_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
+ 
+-static int rockchip_dfi_probe(struct platform_device *pdev)
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,pmugrf", 0);
++	if (node) {
++		data->regmap_pmugrf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmugrf))
++			return PTR_ERR(data->regmap_pmugrf);
++	}
++
++	regmap_read(data->regmap_pmugrf, PX30_PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3128_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
+ {
+-	struct device *dev = &pdev->dev;
+-	struct rockchip_dfi *data;
+-	struct devfreq_event_desc *desc;
+ 	struct device_node *np = pdev->dev.of_node, *node;
+ 
+-	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
+-	if (!data)
+-		return -ENOMEM;
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	desc->ops = &rk3128_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3288_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	u32 val;
++
++	node = of_parse_phandle(np, "rockchip,pmu", 0);
++	if (node) {
++		data->regmap_pmu = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmu))
++			return PTR_ERR(data->regmap_pmu);
++	}
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_pmu, RK3288_PMU_SYS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	if (data->dram_type == DDR3)
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_DDR3_SEL);
++	else
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_LPDDR_SEL);
++
++	desc->ops = &rk3288_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3368_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device *dev = &pdev->dev;
++
++	if (!dev->parent || !dev->parent->of_node)
++		return -EINVAL;
++
++	data->regmap_grf = syscon_node_to_regmap(dev->parent->of_node);
++	if (IS_ERR(data->regmap_grf))
++		return PTR_ERR(data->regmap_grf);
++
++	desc->ops = &rk3368_dfi_ops;
++
++	return 0;
++}
++
++static __init int rockchip_dfi_init(struct platform_device *pdev,
++				    struct rockchip_dfi *data,
++				    struct devfreq_event_desc *desc)
++{
++	struct device *dev = &pdev->dev;
++	struct device_node *np = pdev->dev.of_node, *node;
++	u32 val;
+ 
+ 	data->regs = devm_platform_ioremap_resource(pdev, 0);
+ 	if (IS_ERR(data->regs))
+@@ -202,21 +582,97 @@ static int rockchip_dfi_probe(struct pla
+ 		if (IS_ERR(data->regmap_pmu))
+ 			return PTR_ERR(data->regmap_pmu);
+ 	}
+-	data->dev = dev;
++
++	regmap_read(data->regmap_pmu, PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3328_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_grf, RK3328_GRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static const struct of_device_id rockchip_dfi_id_match[] = {
++	{ .compatible = "rockchip,px30-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk1808-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk3128-dfi", .data = rk3128_dfi_init },
++	{ .compatible = "rockchip,rk3288-dfi", .data = rk3288_dfi_init },
++	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
++	{ .compatible = "rockchip,rk3368-dfi", .data = rk3368_dfi_init },
++	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++
++static int rockchip_dfi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rockchip_dfi *data;
++	struct devfreq_event_desc *desc;
++	struct device_node *np = pdev->dev.of_node;
++	const struct of_device_id *match;
++	int (*init)(struct platform_device *pdev, struct rockchip_dfi *data,
++		    struct devfreq_event_desc *desc);
++
++	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return -ENOMEM;
+ 
+-	desc->ops = &rockchip_dfi_ops;
++	match = of_match_node(rockchip_dfi_id_match, pdev->dev.of_node);
++	if (match) {
++		init = match->data;
++		if (init) {
++			if (init(pdev, data, desc))
++				return -EINVAL;
++		} else {
++			return 0;
++		}
++	} else {
++		return 0;
++	}
++
+ 	desc->driver_data = data;
+ 	desc->name = np->name;
+ 	data->desc = desc;
++	data->dev = dev;
+ 
+-	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
++	data->edev = devm_devfreq_event_add_edev(dev, desc);
+ 	if (IS_ERR(data->edev)) {
+-		dev_err(&pdev->dev,
+-			"failed to add devfreq-event device\n");
++		dev_err(dev, "failed to add devfreq-event device\n");
+ 		return PTR_ERR(data->edev);
+ 	}
+ 
diff --git a/target/linux/rockchip/patches-5.10/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch b/target/linux/rockchip/patches-5.10/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
new file mode 100644
index 0000000000..ebdce52004
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
@@ -0,0 +1,27 @@
+From f9ae6e992d3d9e80357fee7d65ba0fe2dd37ae1f Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 14:21:51 +0800
+Subject: [PATCH] arm64: dts: rockchip: rk3328: add dfi node
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+[adjusted commit title]
+Signed-off-by: Tianling Shen <cnsztl@immortalwrt.org>
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi   |   7 +++++++
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -1021,6 +1021,13 @@
+ 		};
+ 	};
+ 
++	dfi: dfi@ff790000 {
++		reg = <0x00 0xff790000 0x00 0x400>;
++		compatible = "rockchip,rk3328-dfi";
++		rockchip,grf = <&grf>;
++		status = "disabled";
++	};
++
+ 	gic: interrupt-controller@ff811000 {
+ 		compatible = "arm,gic-400";
+ 		#interrupt-cells = <3>;
diff --git a/target/linux/rockchip/patches-5.10/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch b/target/linux/rockchip/patches-5.10/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
new file mode 100644
index 0000000000..d93b9a77b2
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
@@ -0,0 +1,126 @@
+From f9ae6e992d3d9e80357fee7d65ba0fe2dd37ae1f Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 14:21:51 +0800
+Subject: [PATCH] arm64: dts: nanopi-r2: add rk3328-dmc relate node
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ .../rockchip/rk3328-dram-default-timing.dtsi  | 311 ++++++++++++++++++
+ .../dts/rockchip/rk3328-nanopi-r2-common.dtsi |  85 ++++-
+ include/dt-bindings/clock/rockchip-ddr.h      |  63 ++++
+ include/dt-bindings/memory/rk3328-dram.h      | 159 +++++++++
+ 4 files changed, 617 insertions(+), 1 deletion(-)
+ create mode 100644 arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
+ create mode 100644 include/dt-bindings/clock/rockchip-ddr.h
+ create mode 100644 include/dt-bindings/memory/rk3328-dram.h
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+@@ -7,6 +7,7 @@
+ 
+ #include <dt-bindings/input/input.h>
+ #include <dt-bindings/gpio/gpio.h>
++#include "rk3328-dram-nanopi2-timing.dtsi"
+ #include "rk3328.dtsi"
+ 
+ / {
+@@ -115,6 +116,72 @@
+ 		regulator-min-microvolt = <5000000>;
+ 		regulator-max-microvolt = <5000000>;
+ 	};
++
++	dmc: dmc {
++		compatible = "rockchip,rk3328-dmc";
++		devfreq-events = <&dfi>;
++		center-supply = <&vdd_log>;
++		clocks = <&cru SCLK_DDRCLK>;
++		clock-names = "dmc_clk";
++		operating-points-v2 = <&dmc_opp_table>;
++		ddr_timing = <&ddr_timing>;
++		upthreshold = <40>;
++		downdifferential = <20>;
++		auto-min-freq = <786000>;
++		auto-freq-en = <0>;
++		#cooling-cells = <2>;
++		status = "okay";
++
++		ddr_power_model: ddr_power_model {
++			compatible = "ddr_power_model";
++			dynamic-power-coefficient = <120>;
++			static-power-coefficient = <200>;
++			ts = <32000 4700 (-80) 2>;
++			thermal-zone = "soc-thermal";
++		};
++	};
++
++	dmc_opp_table: dmc-opp-table {
++		compatible = "operating-points-v2";
++
++		rockchip,leakage-voltage-sel = <
++			1   10    0
++			11  254   1
++		>;
++		nvmem-cells = <&logic_leakage>;
++		nvmem-cell-names = "ddr_leakage";
++
++		opp-786000000 {
++			opp-hz = /bits/ 64 <786000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-798000000 {
++			opp-hz = /bits/ 64 <798000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-840000000 {
++			opp-hz = /bits/ 64 <840000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-924000000 {
++			opp-hz = /bits/ 64 <924000000>;
++			opp-microvolt = <1100000>;
++			opp-microvolt-L0 = <1100000>;
++			opp-microvolt-L1 = <1075000>;
++		};
++		opp-1056000000 {
++			opp-hz = /bits/ 64 <1056000000>;
++			opp-microvolt = <1175000>;
++			opp-microvolt-L0 = <1175000>;
++			opp-microvolt-L1 = <1150000>;
++		};
++	};
+ };
+ 
+ &cpu0 {
+@@ -137,6 +204,10 @@
+ 	status = "disabled";
+ };
+ 
++&dfi {
++	status = "okay";
++};
++
+ &gmac2io {
+ 	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
+ 	assigned-clock-parents = <&gmac_clk>, <&gmac_clk>;
+@@ -202,6 +273,7 @@
+ 				regulator-name = "vdd_log";
+ 				regulator-always-on;
+ 				regulator-boot-on;
++				regulator-init-microvolt = <1075000>;
+ 				regulator-min-microvolt = <712500>;
+ 				regulator-max-microvolt = <1450000>;
+ 				regulator-ramp-delay = <12500>;
+@@ -216,6 +288,7 @@
+ 				regulator-name = "vdd_arm";
+ 				regulator-always-on;
+ 				regulator-boot-on;
++				regulator-init-microvolt = <1225000>;
+ 				regulator-min-microvolt = <712500>;
+ 				regulator-max-microvolt = <1450000>;
+ 				regulator-ramp-delay = <12500>;
diff --git a/target/linux/rockchip/patches-5.10/911-kernel-dma-adjust-default-coherent_pool-to-2MiB.patch b/target/linux/rockchip/patches-5.10/911-kernel-dma-adjust-default-coherent_pool-to-2MiB.patch
new file mode 100644
index 0000000000..f589ce2a7b
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/911-kernel-dma-adjust-default-coherent_pool-to-2MiB.patch
@@ -0,0 +1,28 @@
+From 16bdf3e76fec6ddb44f1fcf221139fb39d225031 Mon Sep 17 00:00:00 2001
+From: Igor Pecovnik <igor.pecovnik@gmail.com>
+Date: Sat, 2 Jan 2021 05:23:55 +0000
+Subject: [PATCH] kernel: dma: adjust default coherent_pool to 2MiB
+
+---
+ kernel/dma/pool.c | 8 +++-----
+ 1 file changed, 3 insertions(+), 5 deletions(-)
+
+--- a/kernel/dma/pool.c
++++ b/kernel/dma/pool.c
+@@ -192,13 +192,11 @@ static int __init dma_atomic_pool_init(v
+ 	int ret = 0;
+ 
+ 	/*
+-	 * If coherent_pool was not used on the command line, default the pool
+-	 * sizes to 128KB per 1GB of memory, min 128KB, max MAX_ORDER-1.
++	 * Always use 2MiB as default pool size.
++	 * See: https://forum.armbian.com/topic/4811-uas-mainline-kernel-coherent-pool-memory-size/
+ 	 */
+ 	if (!atomic_pool_size) {
+-		unsigned long pages = totalram_pages() / (SZ_1G / SZ_128K);
+-		pages = min_t(unsigned long, pages, MAX_ORDER_NR_PAGES);
+-		atomic_pool_size = max_t(size_t, pages << PAGE_SHIFT, SZ_128K);
++		atomic_pool_size = SZ_2M;
+ 	}
+ 	INIT_WORK(&atomic_pool_work, atomic_pool_work_fn);
+ 
diff --git a/target/linux/rockchip/patches-5.10/991-arm64-dts-rockchip-add-more-cpu-operating-points-for.patch b/target/linux/rockchip/patches-5.10/991-arm64-dts-rockchip-add-more-cpu-operating-points-for.patch
new file mode 100644
index 0000000000..c85da5fb07
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/991-arm64-dts-rockchip-add-more-cpu-operating-points-for.patch
@@ -0,0 +1,44 @@
+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
+From: Leonidas P. Papadakos <papadakospan@gmail.com>
+Date: Fri, 1 Mar 2019 21:55:53 +0200
+Subject: [PATCH v2] arm64: dts: rockchip: add more cpu operating points for
+ RK3328
+
+This allows for greater max frequency on rk3328 boards,
+increasing performance.
+
+It has been included in Armbian (a linux distibution for ARM boards)
+for a while now without any reported issues
+
+https://github.com/armbian/build/blob/master/patch/kernel/rockchip64-default/enable-1392mhz-opp.patch
+https://github.com/armbian/build/blob/master/patch/kernel/rockchip64-default/enable-1512mhz-opp.patch
+
+Signed-off-by: Leonidas P. Papadakos <papadakospan@gmail.com>
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi | 15 +++++++++++++++
+ 1 files changed, 15 insertions(+)
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -140,6 +140,21 @@
+ 			opp-microvolt = <1300000>;
+ 			clock-latency-ns = <40000>;
+ 		};
++		opp-1392000000 {
++			opp-hz = /bits/ 64 <1392000000>;
++			opp-microvolt = <1350000>;
++			clock-latency-ns = <40000>;
++		};
++		opp-1512000000 {
++			opp-hz = /bits/ 64 <1512000000>;
++			opp-microvolt = <1400000>;
++			clock-latency-ns = <40000>;
++		};
++		opp-1608000000 {
++			opp-hz = /bits/ 64 <1608000000>;
++			opp-microvolt = <1450000>;
++			clock-latency-ns = <40000>;
++		};
+ 	};
+ 
+ 	amba: bus {
diff --git a/target/linux/rockchip/patches-5.10/992-rockchip-rk3399-overclock-to-2.2-1.8-GHz-for-NanoPi4.patch b/target/linux/rockchip/patches-5.10/992-rockchip-rk3399-overclock-to-2.2-1.8-GHz-for-NanoPi4.patch
new file mode 100644
index 0000000000..9d393c5771
--- /dev/null
+++ b/target/linux/rockchip/patches-5.10/992-rockchip-rk3399-overclock-to-2.2-1.8-GHz-for-NanoPi4.patch
@@ -0,0 +1,186 @@
+From 04202df5cb497b1934c95211cf43784ef62245a4 Mon Sep 17 00:00:00 2001
+From: Tianling Shen <cnsztl@gmail.com>
+Date: Sat, 19 Dec 2020 12:42:27 +0000
+Subject: [PATCH] rockchip: rk3399: overclock to 2.2/1.8 GHz for NanoPi4 devices
+
+It's stable enough to overclock cpu frequency to 2.2/1.8 GHz,
+and for better performance.
+
+Signed-off-by: Tianling Shen <cnsztl@gmail.com>
+Co-authored-by: gzelvis <gzelvis@gmail.com>
+---
+ .../boot/dts/rockchip/rk3399-nanopi4-opp.dtsi | 156 ++++++++++++++++++
+ .../boot/dts/rockchip/rk3399-nanopi4.dtsi     |   2 +-
+ 2 files changed, 157 insertions(+), 1 deletion(-)
+ create mode 100644 arch/arm64/boot/dts/rockchip/rk3399-nanopi4-opp.dtsi
+
+--- /dev/null
++++ b/arch/arm64/boot/dts/rockchip/rk3399-nanopi4-opp.dtsi
+@@ -0,0 +1,156 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (c) 2016-2017 Fuzhou Rockchip Electronics Co., Ltd
++ *
++ * Copyright (c) 2020 Tianling Shen <cnsztl@gmail.com>
++ * Copyright (c) 2020 gzelvis <gzelvis@gmail.com>
++ */
++
++/ {
++	cluster0_opp: opp-table0 {
++		compatible = "operating-points-v2";
++		opp-shared;
++
++		opp00 {
++			opp-hz = /bits/ 64 <408000000>;
++			opp-microvolt = <800000>;
++			clock-latency-ns = <40000>;
++		};
++		opp01 {
++			opp-hz = /bits/ 64 <600000000>;
++			opp-microvolt = <800000>;
++		};
++		opp02 {
++			opp-hz = /bits/ 64 <816000000>;
++			opp-microvolt = <850000>;
++		};
++		opp03 {
++			opp-hz = /bits/ 64 <1008000000>;
++			opp-microvolt = <925000>;
++		};
++		opp04 {
++			opp-hz = /bits/ 64 <1200000000>;
++			opp-microvolt = <1000000>;
++		};
++		opp05 {
++			opp-hz = /bits/ 64 <1416000000>;
++			opp-microvolt = <1150000>;
++		};
++		opp06 {
++			opp-hz = /bits/ 64 <1512000000>;
++			opp-microvolt = <1200000>;
++		};
++ 		opp07 {
++			opp-hz = /bits/ 64 <1608000000>;
++			opp-microvolt = <1250000>;
++		};
++		opp08 {
++			opp-hz = /bits/ 64 <1800000000>;
++			opp-microvolt = <1300000>;
++		};
++	};
++
++	cluster1_opp: opp-table1 {
++		compatible = "operating-points-v2";
++		opp-shared;
++
++		opp00 {
++			opp-hz = /bits/ 64 <408000000>;
++			opp-microvolt = <800000>;
++			clock-latency-ns = <40000>;
++		};
++		opp01 {
++			opp-hz = /bits/ 64 <600000000>;
++			opp-microvolt = <800000>;
++		};
++		opp02 {
++			opp-hz = /bits/ 64 <816000000>;
++			opp-microvolt = <825000>;
++		};
++		opp03 {
++			opp-hz = /bits/ 64 <1008000000>;
++			opp-microvolt = <875000>;
++		};
++		opp04 {
++			opp-hz = /bits/ 64 <1200000000>;
++			opp-microvolt = <950000>;
++		};
++		opp05 {
++			opp-hz = /bits/ 64 <1416000000>;
++			opp-microvolt = <1025000>;
++		};
++		opp06 {
++			opp-hz = /bits/ 64 <1608000000>;
++			opp-microvolt = <1100000>;
++		};
++		opp07 {
++			opp-hz = /bits/ 64 <1800000000>;
++			opp-microvolt = <1250000>;
++		};
++		opp08 {
++			opp-hz = /bits/ 64 <2016000000>;
++			opp-microvolt = <1350000>;
++		};
++		opp09 {
++			opp-hz = /bits/ 64 <2208000000>;
++			opp-microvolt = <1400000>;
++		};
++	};
++
++	gpu_opp_table: opp-table2 {
++		compatible = "operating-points-v2";
++
++		opp00 {
++			opp-hz = /bits/ 64 <200000000>;
++			opp-microvolt = <800000>;
++		};
++		opp01 {
++			opp-hz = /bits/ 64 <297000000>;
++			opp-microvolt = <800000>;
++		};
++		opp02 {
++			opp-hz = /bits/ 64 <400000000>;
++			opp-microvolt = <825000>;
++		};
++		opp03 {
++			opp-hz = /bits/ 64 <500000000>;
++			opp-microvolt = <875000>;
++		};
++		opp04 {
++			opp-hz = /bits/ 64 <600000000>;
++			opp-microvolt = <925000>;
++		};
++		opp05 {
++			opp-hz = /bits/ 64 <800000000>;
++			opp-microvolt = <1100000>;
++		};
++	};
++};
++
++&cpu_l0 {
++	operating-points-v2 = <&cluster0_opp>;
++};
++
++&cpu_l1 {
++	operating-points-v2 = <&cluster0_opp>;
++};
++
++&cpu_l2 {
++	operating-points-v2 = <&cluster0_opp>;
++};
++
++&cpu_l3 {
++	operating-points-v2 = <&cluster0_opp>;
++};
++
++&cpu_b0 {
++	operating-points-v2 = <&cluster1_opp>;
++};
++
++&cpu_b1 {
++	operating-points-v2 = <&cluster1_opp>;
++};
++
++&gpu {
++	operating-points-v2 = <&gpu_opp_table>;
++};
+--- a/arch/arm64/boot/dts/rockchip/rk3399-nanopi4.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3399-nanopi4.dtsi
+@@ -14,7 +14,7 @@
+ /dts-v1/;
+ #include <dt-bindings/input/linux-event-codes.h>
+ #include "rk3399.dtsi"
+-#include "rk3399-opp.dtsi"
++#include "rk3399-nanopi4-opp.dtsi"
+ 
+ / {
+ 	chosen {
diff --git a/target/linux/rockchip/patches-5.4/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch b/target/linux/rockchip/patches-5.4/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
new file mode 100644
index 0000000000..8d67a11f90
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/803-PM-devfreq-rockchip-add-devfreq-driver-for-rk3328-dmc.patch
@@ -0,0 +1,48 @@
+From fcd9629c05f373771e85920e1c1d0ab252617878 Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 13:53:25 +0800
+Subject: [PATCH] PM / devfreq: rockchip: add devfreq driver for rk3328 dmc
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/Kconfig      |  18 +-
+ drivers/devfreq/Makefile     |   1 +
+ drivers/devfreq/rk3328_dmc.c | 846 +++++++++++++++++++++++++++++++++++
+ 3 files changed, 862 insertions(+), 3 deletions(-)
+ create mode 100644 drivers/devfreq/rk3328_dmc.c
+
+diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
+index defe1d438710..5ae0832f046b 100644
+--- a/drivers/devfreq/Kconfig
++++ b/drivers/devfreq/Kconfig
+@@ -116,6 +116,18 @@ config ARM_TEGRA20_DEVFREQ
+ 	  It reads Memory Controller counters and adjusts the operating
+ 	  frequencies and voltages with OPP support.
+ 
++config ARM_RK3328_DMC_DEVFREQ
++	tristate "ARM RK3328 DMC DEVFREQ Driver"
++	depends on ARCH_ROCKCHIP
++	select DEVFREQ_EVENT_ROCKCHIP_DFI
++	select DEVFREQ_GOV_SIMPLE_ONDEMAND
++	select PM_DEVFREQ_EVENT
++	select PM_OPP
++	help
++	  This adds the DEVFREQ driver for the RK3328 DMC(Dynamic Memory Controller).
++	  It sets the frequency for the memory controller and reads the usage counts
++	  from hardware.
++
+ config ARM_RK3399_DMC_DEVFREQ
+ 	tristate "ARM RK3399 DMC DEVFREQ Driver"
+ 	depends on ARCH_ROCKCHIP
+diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
+index 338ae8440db6..ec568406ef50 100644
+--- a/drivers/devfreq/Makefile
++++ b/drivers/devfreq/Makefile
+@@ -9,6 +9,7 @@ obj-$(CONFIG_DEVFREQ_GOV_PASSIVE)	+= governor_passive.o
+ 
+ # DEVFREQ Drivers
+ obj-$(CONFIG_ARM_EXYNOS_BUS_DEVFREQ)	+= exynos-bus.o
++obj-$(CONFIG_ARM_RK3328_DMC_DEVFREQ)	+= rk3328_dmc.o
+ obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
+ obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
+ obj-$(CONFIG_ARM_TEGRA20_DEVFREQ)	+= tegra20-devfreq.o
diff --git a/target/linux/rockchip/patches-5.4/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch b/target/linux/rockchip/patches-5.4/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
new file mode 100644
index 0000000000..4e688f8eb4
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/804-clk-rockchip-support-setting-ddr-clock-via-SIP-Version-2-.patch
@@ -0,0 +1,218 @@
+From ce6d3614888e6358466f0e84e248177a6bca5258 Mon Sep 17 00:00:00 2001
+From: Tang Yun ping <typ@rock-chips.com>
+Date: Thu, 4 May 2017 20:49:58 +0800
+Subject: [PATCH] clk: rockchip: support setting ddr clock via SIP Version 2
+ APIs
+
+commit 764e893ee82321938fc6f4349e9e7caf06a04410 rockchip.
+
+Signed-off-by: Tang Yun ping <typ@rock-chips.com>
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/clk/rockchip/clk-ddr.c      | 130 ++++++++++++++++++++++++++++
+ drivers/clk/rockchip/clk-rk3328.c   |   7 +-
+ drivers/clk/rockchip/clk.h          |   3 +-
+ include/soc/rockchip/rockchip_sip.h |  11 +++
+ 4 files changed, 147 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/clk/rockchip/clk-ddr.c b/drivers/clk/rockchip/clk-ddr.c
+index 9273bce4d7b6..555aaf4e758d 100644
+--- a/drivers/clk/rockchip/clk-ddr.c
++++ b/drivers/clk/rockchip/clk-ddr.c
+@@ -87,6 +87,133 @@ static const struct clk_ops rockchip_ddrclk_sip_ops = {
+ 	.get_parent = rockchip_ddrclk_get_parent,
+ };
+ 
++/* See v4.4/include/dt-bindings/display/rk_fb.h */
++#define SCREEN_NULL			0
++#define SCREEN_HDMI			6
++
++static inline int rk_drm_get_lcdc_type(void)
++{
++	return SCREEN_NULL;
++}
++
++struct share_params {
++	u32 hz;
++	u32 lcdc_type;
++	u32 vop;
++	u32 vop_dclk_mode;
++	u32 sr_idle_en;
++	u32 addr_mcu_el3;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag1;
++	/*
++	 * 1: need to wait flag1
++	 * 0: never wait flag1
++	 */
++	u32 wait_flag0;
++	u32 complt_hwirq;
++	 /* if need, add parameter after */
++};
++
++struct rockchip_ddrclk_data {
++	u32 inited_flag;
++	void __iomem *share_memory;
++};
++
++static struct rockchip_ddrclk_data ddr_data;
++
++static void rockchip_ddrclk_data_init(void)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_SHARE_MEM,
++		      1, SHARE_PAGE_TYPE_DDR, 0,
++		      0, 0, 0, 0, &res);
++
++	if (!res.a0) {
++		ddr_data.share_memory = (void __iomem *)ioremap(res.a1, 1<<12);
++		ddr_data.inited_flag = 1;
++	}
++}
++
++static int rockchip_ddrclk_sip_set_rate_v2(struct clk_hw *hw,
++					   unsigned long drate,
++					   unsigned long prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = drate;
++	p->lcdc_type = rk_drm_get_lcdc_type();
++	p->wait_flag1 = 1;
++	p->wait_flag0 = 1;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_SET_RATE,
++		      0, 0, 0, 0, &res);
++
++	if ((int)res.a1 == -6) {
++		pr_err("%s: timeout, drate = %lumhz\n", __func__, drate/1000000);
++		/* TODO: rockchip_dmcfreq_wait_complete(); */
++	}
++
++	return res.a0;
++}
++
++static unsigned long rockchip_ddrclk_sip_recalc_rate_v2
++			(struct clk_hw *hw, unsigned long parent_rate)
++{
++	struct arm_smccc_res res;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_GET_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static long rockchip_ddrclk_sip_round_rate_v2(struct clk_hw *hw,
++					      unsigned long rate,
++					      unsigned long *prate)
++{
++	struct share_params *p;
++	struct arm_smccc_res res;
++
++	if (!ddr_data.inited_flag)
++		rockchip_ddrclk_data_init();
++
++	p = (struct share_params *)ddr_data.share_memory;
++
++	p->hz = rate;
++
++	arm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ,
++		      SHARE_PAGE_TYPE_DDR, 0,
++		      ROCKCHIP_SIP_CONFIG_DRAM_ROUND_RATE,
++		      0, 0, 0, 0, &res);
++	if (!res.a0)
++		return res.a1;
++	else
++		return 0;
++}
++
++static const struct clk_ops rockchip_ddrclk_sip_ops_v2 = {
++	.recalc_rate = rockchip_ddrclk_sip_recalc_rate_v2,
++	.set_rate = rockchip_ddrclk_sip_set_rate_v2,
++	.round_rate = rockchip_ddrclk_sip_round_rate_v2,
++	.get_parent = rockchip_ddrclk_get_parent,
++};
++
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+ 					 u8 num_parents, int mux_offset,
+@@ -114,6 +241,9 @@ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 	case ROCKCHIP_DDRCLK_SIP:
+ 		init.ops = &rockchip_ddrclk_sip_ops;
+ 		break;
++	case ROCKCHIP_DDRCLK_SIP_V2:
++		init.ops = &rockchip_ddrclk_sip_ops_v2;
++		break;
+ 	default:
+ 		pr_err("%s: unsupported ddrclk type %d\n", __func__, ddr_flag);
+ 		kfree(ddrclk);
+diff --git a/drivers/clk/rockchip/clk-rk3328.c b/drivers/clk/rockchip/clk-rk3328.c
+index c186a1985bf4..ac6e6163a232 100644
+--- a/drivers/clk/rockchip/clk-rk3328.c
++++ b/drivers/clk/rockchip/clk-rk3328.c
+@@ -314,9 +314,10 @@ static struct rockchip_clk_branch rk3328_clk_branches[] __initdata = {
+ 			RK3328_CLKGATE_CON(14), 1, GFLAGS),
+ 
+ 	/* PD_DDR */
+-	COMPOSITE(0, "clk_ddr", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+-			RK3328_CLKSEL_CON(3), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
+-			RK3328_CLKGATE_CON(0), 4, GFLAGS),
++	COMPOSITE_DDRCLK(SCLK_DDRCLK, "sclk_ddrc", mux_ddrphy_p, 0,
++			RK3328_CLKSEL_CON(3), 8, 2, 0, 3,
++			ROCKCHIP_DDRCLK_SIP_V2),
++
+ 	GATE(0, "clk_ddrmsch", "clk_ddr", CLK_IGNORE_UNUSED,
+ 			RK3328_CLKGATE_CON(18), 6, GFLAGS),
+ 	GATE(0, "clk_ddrupctl", "clk_ddr", CLK_IGNORE_UNUSED,
+diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
+index 2271a84124b0..7405aaf965ec 100644
+--- a/drivers/clk/rockchip/clk.h
++++ b/drivers/clk/rockchip/clk.h
+@@ -362,7 +362,8 @@ struct clk *rockchip_clk_register_mmc(const char *name,
+  * DDRCLK flags, including method of setting the rate
+  * ROCKCHIP_DDRCLK_SIP: use SIP call to bl31 to change ddrclk rate.
+  */
+-#define ROCKCHIP_DDRCLK_SIP		BIT(0)
++#define ROCKCHIP_DDRCLK_SIP		0x01
++#define ROCKCHIP_DDRCLK_SIP_V2		0x03
+ 
+ struct clk *rockchip_clk_register_ddrclk(const char *name, int flags,
+ 					 const char *const *parent_names,
+diff --git a/include/soc/rockchip/rockchip_sip.h b/include/soc/rockchip/rockchip_sip.h
+index c46a9ae2a2ab..fa7e0a2d72cc 100644
+--- a/include/soc/rockchip/rockchip_sip.h
++++ b/include/soc/rockchip/rockchip_sip.h
+@@ -16,5 +16,16 @@
+ #define ROCKCHIP_SIP_CONFIG_DRAM_CLR_IRQ	0x06
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_PARAM	0x07
+ #define ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD	0x08
++#define ROCKCHIP_SIP_CONFIG_DRAM_GET_VERSION	0x08
++
++#define ROCKCHIP_SIP_SHARE_MEM			0x82000009
++
++/* Share mem page types */
++typedef enum {
++    SHARE_PAGE_TYPE_INVALID = 0,
++    SHARE_PAGE_TYPE_UARTDBG,
++    SHARE_PAGE_TYPE_DDR,
++    SHARE_PAGE_TYPE_MAX,
++} share_page_type_t;
+ 
+ #endif
diff --git a/target/linux/rockchip/patches-5.4/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch b/target/linux/rockchip/patches-5.4/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
new file mode 100644
index 0000000000..dbf491a287
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/805-PM-devfreq-rockchip-dfi-add-more-soc-support.patch
@@ -0,0 +1,665 @@
+From 4db93c6dad0c71750b86163df2fdb21c35f00d9a Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 12:49:48 +0800
+Subject: [PATCH] PM / devfreq: rockchip-dfi: add more soc support
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ drivers/devfreq/event/rockchip-dfi.c | 554 ++++++++++++++++++++++++---
+ 1 file changed, 505 insertions(+), 49 deletions(-)
+
+diff --git a/drivers/devfreq/event/rockchip-dfi.c b/drivers/devfreq/event/rockchip-dfi.c
+index 5d1042188727..80be0efdfb9b 100644
+--- a/drivers/devfreq/event/rockchip-dfi.c
++++ b/drivers/devfreq/event/rockchip-dfi.c
+@@ -18,25 +18,66 @@
+ #include <linux/list.h>
+ #include <linux/of.h>
+ 
+-#include <soc/rockchip/rk3399_grf.h>
+-
+-#define RK3399_DMC_NUM_CH	2
+-
++#define PX30_PMUGRF_OS_REG2		0x208
++
++#define RK3128_GRF_SOC_CON0		0x140
++#define RK3128_GRF_OS_REG1		0x1cc
++#define RK3128_GRF_DFI_WRNUM		0x220
++#define RK3128_GRF_DFI_RDNUM		0x224
++#define RK3128_GRF_DFI_TIMERVAL		0x22c
++#define RK3128_DDR_MONITOR_EN		((1 << (16 + 6)) + (1 << 6))
++#define RK3128_DDR_MONITOR_DISB		((1 << (16 + 6)) + (0 << 6))
++
++#define RK3288_PMU_SYS_REG2		0x9c
++#define RK3288_GRF_SOC_CON4		0x254
++#define RK3288_GRF_SOC_STATUS(n)	(0x280 + (n) * 4)
++#define RK3288_DFI_EN			(0x30003 << 14)
++#define RK3288_DFI_DIS			(0x30000 << 14)
++#define RK3288_LPDDR_SEL		(0x10001 << 13)
++#define RK3288_DDR3_SEL			(0x10000 << 13)
++
++#define RK3328_GRF_OS_REG2		0x5d0
++
++#define RK3368_GRF_DDRC0_CON0		0x600
++#define RK3368_GRF_SOC_STATUS5		0x494
++#define RK3368_GRF_SOC_STATUS6		0x498
++#define RK3368_GRF_SOC_STATUS8		0x4a0
++#define RK3368_GRF_SOC_STATUS9		0x4a4
++#define RK3368_GRF_SOC_STATUS10		0x4a8
++#define RK3368_DFI_EN			(0x30003 << 5)
++#define RK3368_DFI_DIS			(0x30000 << 5)
++
++#define MAX_DMC_NUM_CH			2
++#define READ_DRAMTYPE_INFO(n)		(((n) >> 13) & 0x7)
++#define READ_CH_INFO(n)			(((n) >> 28) & 0x3)
+ /* DDRMON_CTRL */
+-#define DDRMON_CTRL	0x04
+-#define CLR_DDRMON_CTRL	(0x1f0000 << 0)
+-#define LPDDR4_EN	(0x10001 << 4)
+-#define HARDWARE_EN	(0x10001 << 3)
+-#define LPDDR3_EN	(0x10001 << 2)
+-#define SOFTWARE_EN	(0x10001 << 1)
+-#define SOFTWARE_DIS	(0x10000 << 1)
+-#define TIME_CNT_EN	(0x10001 << 0)
++#define DDRMON_CTRL			0x04
++#define CLR_DDRMON_CTRL			(0x3f0000 << 0)
++#define DDR4_EN				(0x10001 << 5)
++#define LPDDR4_EN			(0x10001 << 4)
++#define HARDWARE_EN			(0x10001 << 3)
++#define LPDDR2_3_EN			(0x10001 << 2)
++#define SOFTWARE_EN			(0x10001 << 1)
++#define SOFTWARE_DIS			(0x10000 << 1)
++#define TIME_CNT_EN			(0x10001 << 0)
+ 
+ #define DDRMON_CH0_COUNT_NUM		0x28
+ #define DDRMON_CH0_DFI_ACCESS_NUM	0x2c
+ #define DDRMON_CH1_COUNT_NUM		0x3c
+ #define DDRMON_CH1_DFI_ACCESS_NUM	0x40
+ 
++/* pmu grf */
++#define PMUGRF_OS_REG2			0x308
++
++enum {
++	DDR4 = 0,
++	DDR3 = 3,
++	LPDDR2 = 5,
++	LPDDR3 = 6,
++	LPDDR4 = 7,
++	UNUSED = 0xFF
++};
++
+ struct dmc_usage {
+ 	u32 access;
+ 	u32 total;
+@@ -50,33 +91,261 @@ struct dmc_usage {
+ struct rockchip_dfi {
+ 	struct devfreq_event_dev *edev;
+ 	struct devfreq_event_desc *desc;
+-	struct dmc_usage ch_usage[RK3399_DMC_NUM_CH];
++	struct dmc_usage ch_usage[MAX_DMC_NUM_CH];
+ 	struct device *dev;
+ 	void __iomem *regs;
+ 	struct regmap *regmap_pmu;
++	struct regmap *regmap_grf;
++	struct regmap *regmap_pmugrf;
+ 	struct clk *clk;
++	u32 dram_type;
++	/*
++	 * available mask, 1: available, 0: not available
++	 * each bit represent a channel
++	 */
++	u32 ch_msk;
++};
++
++static void rk3128_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_EN);
++}
++
++static void rk3128_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf,
++		     RK3128_GRF_SOC_CON0,
++		     RK3128_DDR_MONITOR_DISB);
++}
++
++static int rk3128_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3128_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3128_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3128_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi_wr, dfi_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3128_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_WRNUM, &dfi_wr);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_RDNUM, &dfi_rd);
++	regmap_read(info->regmap_grf, RK3128_GRF_DFI_TIMERVAL, &dfi_timer);
++
++	edata->load_count = (dfi_wr + dfi_rd) * 4;
++	edata->total_count = dfi_timer;
++
++	rk3128_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3128_dfi_ops = {
++	.disable = rk3128_dfi_disable,
++	.enable = rk3128_dfi_enable,
++	.get_event = rk3128_dfi_get_event,
++	.set_event = rk3128_dfi_set_event,
++};
++
++static void rk3288_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_EN);
++}
++
++static void rk3288_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3288_GRF_SOC_CON4, RK3288_DFI_DIS);
++}
++
++static int rk3288_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3288_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3288_dfi_get_busier_ch(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	u32 tmp, max = 0;
++	u32 i, busier_ch = 0;
++	u32 rd_count, wr_count, total_count;
++
++	rk3288_dfi_stop_hardware_counter(edev);
++
++	/* Find out which channel is busier */
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(11 + i * 4), &wr_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(12 + i * 4), &rd_count);
++		regmap_read(info->regmap_grf,
++			    RK3288_GRF_SOC_STATUS(14 + i * 4), &total_count);
++		info->ch_usage[i].access = (wr_count + rd_count) * 4;
++		info->ch_usage[i].total = total_count;
++		tmp = info->ch_usage[i].access;
++		if (tmp > max) {
++			busier_ch = i;
++			max = tmp;
++		}
++	}
++	rk3288_dfi_start_hardware_counter(edev);
++
++	return busier_ch;
++}
++
++static int rk3288_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	int busier_ch;
++	unsigned long flags;
++
++	local_irq_save(flags);
++	busier_ch = rk3288_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
++
++	edata->load_count = info->ch_usage[busier_ch].access;
++	edata->total_count = info->ch_usage[busier_ch].total;
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3288_dfi_ops = {
++	.disable = rk3288_dfi_disable,
++	.enable = rk3288_dfi_enable,
++	.get_event = rk3288_dfi_get_event,
++	.set_event = rk3288_dfi_set_event,
++};
++
++static void rk3368_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_EN);
++}
++
++static void rk3368_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++
++	regmap_write(info->regmap_grf, RK3368_GRF_DDRC0_CON0, RK3368_DFI_DIS);
++}
++
++static int rk3368_dfi_disable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_enable(struct devfreq_event_dev *edev)
++{
++	rk3368_dfi_start_hardware_counter(edev);
++
++	return 0;
++}
++
++static int rk3368_dfi_set_event(struct devfreq_event_dev *edev)
++{
++	return 0;
++}
++
++static int rk3368_dfi_get_event(struct devfreq_event_dev *edev,
++				struct devfreq_event_data *edata)
++{
++	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
++	unsigned long flags;
++	u32 dfi0_wr, dfi0_rd, dfi1_wr, dfi1_rd, dfi_timer;
++
++	local_irq_save(flags);
++
++	rk3368_dfi_stop_hardware_counter(edev);
++
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS5, &dfi0_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS6, &dfi0_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS9, &dfi1_wr);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS10, &dfi1_rd);
++	regmap_read(info->regmap_grf, RK3368_GRF_SOC_STATUS8, &dfi_timer);
++
++	edata->load_count = (dfi0_wr + dfi0_rd + dfi1_wr + dfi1_rd) * 2;
++	edata->total_count = dfi_timer;
++
++	rk3368_dfi_start_hardware_counter(edev);
++
++	local_irq_restore(flags);
++
++	return 0;
++}
++
++static const struct devfreq_event_ops rk3368_dfi_ops = {
++	.disable = rk3368_dfi_disable,
++	.enable = rk3368_dfi_enable,
++	.get_event = rk3368_dfi_get_event,
++	.set_event = rk3368_dfi_set_event,
+ };
+ 
+ static void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	void __iomem *dfi_regs = info->regs;
+-	u32 val;
+-	u32 ddr_type;
+-
+-	/* get ddr type */
+-	regmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);
+-	ddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &
+-		    RK3399_PMUGRF_DDRTYPE_MASK;
+ 
+ 	/* clear DDRMON_CTRL setting */
+ 	writel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* set ddr type to dfi */
+-	if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)
+-		writel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);
+-	else if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)
++	if (info->dram_type == LPDDR3 || info->dram_type == LPDDR2)
++		writel_relaxed(LPDDR2_3_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == LPDDR4)
+ 		writel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);
++	else if (info->dram_type == DDR4)
++		writel_relaxed(DDR4_EN, dfi_regs + DDRMON_CTRL);
+ 
+ 	/* enable count, use software mode */
+ 	writel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);
+@@ -100,12 +369,22 @@ static int rockchip_dfi_get_busier_ch(struct devfreq_event_dev *edev)
+ 	rockchip_dfi_stop_hardware_counter(edev);
+ 
+ 	/* Find out which channel is busier */
+-	for (i = 0; i < RK3399_DMC_NUM_CH; i++) {
+-		info->ch_usage[i].access = readl_relaxed(dfi_regs +
+-				DDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;
++	for (i = 0; i < MAX_DMC_NUM_CH; i++) {
++		if (!(info->ch_msk & BIT(i)))
++			continue;
++
+ 		info->ch_usage[i].total = readl_relaxed(dfi_regs +
+ 				DDRMON_CH0_COUNT_NUM + i * 20);
+-		tmp = info->ch_usage[i].access;
++
++		/* LPDDR4 BL = 16,other DDR type BL = 8 */
++		tmp = readl_relaxed(dfi_regs +
++				DDRMON_CH0_DFI_ACCESS_NUM + i * 20);
++		if (info->dram_type == LPDDR4)
++			tmp *= 8;
++		else
++			tmp *= 4;
++		info->ch_usage[i].access = tmp;
++
+ 		if (tmp > max) {
+ 			busier_ch = i;
+ 			max = tmp;
+@@ -121,7 +400,8 @@ static int rockchip_dfi_disable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 
+ 	rockchip_dfi_stop_hardware_counter(edev);
+-	clk_disable_unprepare(info->clk);
++	if (info->clk)
++		clk_disable_unprepare(info->clk);
+ 
+ 	return 0;
+ }
+@@ -131,10 +411,13 @@ static int rockchip_dfi_enable(struct devfreq_event_dev *edev)
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int ret;
+ 
+-	ret = clk_prepare_enable(info->clk);
+-	if (ret) {
+-		dev_err(&edev->dev, "failed to enable dfi clk: %d\n", ret);
+-		return ret;
++	if (info->clk) {
++		ret = clk_prepare_enable(info->clk);
++		if (ret) {
++			dev_err(&edev->dev, "failed to enable dfi clk: %d\n",
++				ret);
++			return ret;
++		}
+ 	}
+ 
+ 	rockchip_dfi_start_hardware_counter(edev);
+@@ -151,8 +434,11 @@ static int rockchip_dfi_get_event(struct devfreq_event_dev *edev,
+ {
+ 	struct rockchip_dfi *info = devfreq_event_get_drvdata(edev);
+ 	int busier_ch;
++	unsigned long flags;
+ 
++	local_irq_save(flags);
+ 	busier_ch = rockchip_dfi_get_busier_ch(edev);
++	local_irq_restore(flags);
+ 
+ 	edata->load_count = info->ch_usage[busier_ch].access;
+ 	edata->total_count = info->ch_usage[busier_ch].total;
+@@ -167,23 +453,117 @@ static const struct devfreq_event_ops rockchip_dfi_ops = {
+ 	.set_event = rockchip_dfi_set_event,
+ };
+ 
+-static const struct of_device_id rockchip_dfi_id_match[] = {
+-	{ .compatible = "rockchip,rk3399-dfi" },
+-	{ },
+-};
+-MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++static __init int px30_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
+ 
+-static int rockchip_dfi_probe(struct platform_device *pdev)
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,pmugrf", 0);
++	if (node) {
++		data->regmap_pmugrf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmugrf))
++			return PTR_ERR(data->regmap_pmugrf);
++	}
++
++	regmap_read(data->regmap_pmugrf, PX30_PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3128_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	desc->ops = &rk3128_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3288_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	u32 val;
++
++	node = of_parse_phandle(np, "rockchip,pmu", 0);
++	if (node) {
++		data->regmap_pmu = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_pmu))
++			return PTR_ERR(data->regmap_pmu);
++	}
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_pmu, RK3288_PMU_SYS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	if (data->dram_type == DDR3)
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_DDR3_SEL);
++	else
++		regmap_write(data->regmap_grf, RK3288_GRF_SOC_CON4,
++			     RK3288_LPDDR_SEL);
++
++	desc->ops = &rk3288_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3368_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device *dev = &pdev->dev;
++
++	if (!dev->parent || !dev->parent->of_node)
++		return -EINVAL;
++
++	data->regmap_grf = syscon_node_to_regmap(dev->parent->of_node);
++	if (IS_ERR(data->regmap_grf))
++		return PTR_ERR(data->regmap_grf);
++
++	desc->ops = &rk3368_dfi_ops;
++
++	return 0;
++}
++
++static __init int rockchip_dfi_init(struct platform_device *pdev,
++				    struct rockchip_dfi *data,
++				    struct devfreq_event_desc *desc)
+ {
+ 	struct device *dev = &pdev->dev;
+-	struct rockchip_dfi *data;
+ 	struct resource *res;
+-	struct devfreq_event_desc *desc;
+ 	struct device_node *np = pdev->dev.of_node, *node;
+-
+-	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
+-	if (!data)
+-		return -ENOMEM;
++	u32 val;
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	data->regs = devm_ioremap_resource(&pdev->dev, res);
+@@ -203,21 +583,97 @@ static int rockchip_dfi_probe(struct platform_device *pdev)
+ 		if (IS_ERR(data->regmap_pmu))
+ 			return PTR_ERR(data->regmap_pmu);
+ 	}
+-	data->dev = dev;
++
++	regmap_read(data->regmap_pmu, PMUGRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = READ_CH_INFO(val);
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static __init int rk3328_dfi_init(struct platform_device *pdev,
++				  struct rockchip_dfi *data,
++				  struct devfreq_event_desc *desc)
++{
++	struct device_node *np = pdev->dev.of_node, *node;
++	struct resource *res;
++	u32 val;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs))
++		return PTR_ERR(data->regs);
++
++	node = of_parse_phandle(np, "rockchip,grf", 0);
++	if (node) {
++		data->regmap_grf = syscon_node_to_regmap(node);
++		if (IS_ERR(data->regmap_grf))
++			return PTR_ERR(data->regmap_grf);
++	}
++
++	regmap_read(data->regmap_grf, RK3328_GRF_OS_REG2, &val);
++	data->dram_type = READ_DRAMTYPE_INFO(val);
++	data->ch_msk = 1;
++	data->clk = NULL;
++
++	desc->ops = &rockchip_dfi_ops;
++
++	return 0;
++}
++
++static const struct of_device_id rockchip_dfi_id_match[] = {
++	{ .compatible = "rockchip,px30-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk1808-dfi", .data = px30_dfi_init },
++	{ .compatible = "rockchip,rk3128-dfi", .data = rk3128_dfi_init },
++	{ .compatible = "rockchip,rk3288-dfi", .data = rk3288_dfi_init },
++	{ .compatible = "rockchip,rk3328-dfi", .data = rk3328_dfi_init },
++	{ .compatible = "rockchip,rk3368-dfi", .data = rk3368_dfi_init },
++	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);
++
++static int rockchip_dfi_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct rockchip_dfi *data;
++	struct devfreq_event_desc *desc;
++	struct device_node *np = pdev->dev.of_node;
++	const struct of_device_id *match;
++	int (*init)(struct platform_device *pdev, struct rockchip_dfi *data,
++		    struct devfreq_event_desc *desc);
++
++	data = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return -ENOMEM;
+ 
+-	desc->ops = &rockchip_dfi_ops;
++	match = of_match_node(rockchip_dfi_id_match, pdev->dev.of_node);
++	if (match) {
++		init = match->data;
++		if (init) {
++			if (init(pdev, data, desc))
++				return -EINVAL;
++		} else {
++			return 0;
++		}
++	} else {
++		return 0;
++	}
++
+ 	desc->driver_data = data;
+ 	desc->name = np->name;
+ 	data->desc = desc;
++	data->dev = dev;
+ 
+-	data->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);
++	data->edev = devm_devfreq_event_add_edev(dev, desc);
+ 	if (IS_ERR(data->edev)) {
+-		dev_err(&pdev->dev,
+-			"failed to add devfreq-event device\n");
++		dev_err(dev, "failed to add devfreq-event device\n");
+ 		return PTR_ERR(data->edev);
+ 	}
diff --git a/target/linux/rockchip/patches-5.4/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch b/target/linux/rockchip/patches-5.4/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
new file mode 100644
index 0000000000..e9b79b6fa9
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/806-arm64-dts-rockchip-rk3328-add-dfi-node.patch
@@ -0,0 +1,27 @@
+From f9ae6e992d3d9e80357fee7d65ba0fe2dd37ae1f Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 14:21:51 +0800
+Subject: [PATCH] arm64: dts: rockchip: rk3328: add dfi node
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+[adjusted commit title]
+Signed-off-by: Tianling Shen <cnsztl@immortalwrt.org>
+---
+ arch/arm64/boot/dts/rockchip/rk3328.dtsi   |   7 +++++++
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
++++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+@@ -993,6 +993,13 @@
+ 		};
+ 	};
+ 
++	dfi: dfi@ff790000 {
++		reg = <0x00 0xff790000 0x00 0x400>;
++		compatible = "rockchip,rk3328-dfi";
++		rockchip,grf = <&grf>;
++		status = "disabled";
++	};
++
+ 	gic: interrupt-controller@ff811000 {
+ 		compatible = "arm,gic-400";
+ 		#interrupt-cells = <3>;
diff --git a/target/linux/rockchip/patches-5.4/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch b/target/linux/rockchip/patches-5.4/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
new file mode 100644
index 0000000000..0298ccfab1
--- /dev/null
+++ b/target/linux/rockchip/patches-5.4/807-arm64-dts-nanopi-r2s-add-rk3328-dmc-relate-node.patch
@@ -0,0 +1,126 @@
+From f9ae6e992d3d9e80357fee7d65ba0fe2dd37ae1f Mon Sep 17 00:00:00 2001
+From: hmz007 <hmz007@gmail.com>
+Date: Tue, 19 Nov 2019 14:21:51 +0800
+Subject: [PATCH] arm64: dts: nanopi-r2: add rk3328-dmc relate node
+
+Signed-off-by: hmz007 <hmz007@gmail.com>
+---
+ .../rockchip/rk3328-dram-default-timing.dtsi  | 311 ++++++++++++++++++
+ .../dts/rockchip/rk3328-nanopi-r2-common.dtsi |  85 ++++-
+ include/dt-bindings/clock/rockchip-ddr.h      |  63 ++++
+ include/dt-bindings/memory/rk3328-dram.h      | 159 +++++++++
+ 4 files changed, 617 insertions(+), 1 deletion(-)
+ create mode 100644 arch/arm64/boot/dts/rockchip/rk3328-dram-default-timing.dtsi
+ create mode 100644 include/dt-bindings/clock/rockchip-ddr.h
+ create mode 100644 include/dt-bindings/memory/rk3328-dram.h
+
+--- a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
++++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2s.dts
+@@ -7,6 +7,7 @@
+ 
+ #include <dt-bindings/input/input.h>
+ #include <dt-bindings/gpio/gpio.h>
++#include "rk3328-dram-nanopi2-timing.dtsi"
+ #include "rk3328.dtsi"
+ 
+ / {
+@@ -115,6 +116,72 @@
+ 		regulator-max-microvolt = <5000000>;
+ 		enable-active-high;
+ 	};
++
++	dmc: dmc {
++		compatible = "rockchip,rk3328-dmc";
++		devfreq-events = <&dfi>;
++		center-supply = <&vdd_log>;
++		clocks = <&cru SCLK_DDRCLK>;
++		clock-names = "dmc_clk";
++		operating-points-v2 = <&dmc_opp_table>;
++		ddr_timing = <&ddr_timing>;
++		upthreshold = <40>;
++		downdifferential = <20>;
++		auto-min-freq = <786000>;
++		auto-freq-en = <0>;
++		#cooling-cells = <2>;
++		status = "okay";
++
++		ddr_power_model: ddr_power_model {
++			compatible = "ddr_power_model";
++			dynamic-power-coefficient = <120>;
++			static-power-coefficient = <200>;
++			ts = <32000 4700 (-80) 2>;
++			thermal-zone = "soc-thermal";
++		};
++	};
++
++	dmc_opp_table: dmc-opp-table {
++		compatible = "operating-points-v2";
++
++		rockchip,leakage-voltage-sel = <
++			1   10    0
++			11  254   1
++		>;
++		nvmem-cells = <&logic_leakage>;
++		nvmem-cell-names = "ddr_leakage";
++
++		opp-786000000 {
++			opp-hz = /bits/ 64 <786000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-798000000 {
++			opp-hz = /bits/ 64 <798000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-840000000 {
++			opp-hz = /bits/ 64 <840000000>;
++			opp-microvolt = <1075000>;
++			opp-microvolt-L0 = <1075000>;
++			opp-microvolt-L1 = <1050000>;
++		};
++		opp-924000000 {
++			opp-hz = /bits/ 64 <924000000>;
++			opp-microvolt = <1100000>;
++			opp-microvolt-L0 = <1100000>;
++			opp-microvolt-L1 = <1075000>;
++		};
++		opp-1056000000 {
++			opp-hz = /bits/ 64 <1056000000>;
++			opp-microvolt = <1175000>;
++			opp-microvolt-L0 = <1175000>;
++			opp-microvolt-L1 = <1150000>;
++		};
++	};
+ };
+ 
+ &cpu0 {
+@@ -133,6 +200,10 @@
+ 	cpu-supply = <&vdd_arm>;
+ };
+ 
++&dfi {
++	status = "okay";
++};
++
+ &gmac2io {
+ 	assigned-clocks = <&cru SCLK_MAC2IO>, <&cru SCLK_MAC2IO_EXT>;
+ 	assigned-clock-parents = <&gmac_clk>, <&gmac_clk>;
+@@ -198,6 +269,7 @@
+ 				regulator-name = "vdd_log";
+ 				regulator-always-on;
+ 				regulator-boot-on;
++				regulator-init-microvolt = <1075000>;
+ 				regulator-min-microvolt = <712500>;
+ 				regulator-max-microvolt = <1450000>;
+ 				regulator-ramp-delay = <12500>;
+@@ -212,6 +284,7 @@
+ 				regulator-name = "vdd_arm";
+ 				regulator-always-on;
+ 				regulator-boot-on;
++				regulator-init-microvolt = <1225000>;
+ 				regulator-min-microvolt = <712500>;
+ 				regulator-max-microvolt = <1450000>;
+ 				regulator-ramp-delay = <12500>;
-- 
2.25.1

